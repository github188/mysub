<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">JBoss Cache 用户向导</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/></head><body><div class="book" lang="zh-CN"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e1"/>JBoss Cache 用户向导</h1></div><div><h2 class="subtitle">支持集群、事务的缓存技术</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Manik</span> <span class="surname">Surtani</span></h3><code class="email">&lt;<a href="mailto:manik@jboss.org">manik@jboss.org</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">Bela</span> <span class="surname">Ban</span></h3><code class="email">&lt;<a href="mailto:bela@jboss.com">bela@jboss.com</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="surname">Wang</span></h3><code class="email">&lt;<a href="mailto:ben.wang@jboss.com">ben.wang@jboss.com</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">Brian</span> <span class="surname">Stansberry</span></h3><code class="email">&lt;<a href="mailto:brian.stansberry@jboss.com">brian.stansberry@jboss.com</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">Galder</span> <span class="surname">Zamarreño</span></h3><code class="email">&lt;<a href="mailto:galder.zamarreno@jboss.com">galder.zamarreno@jboss.com</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">Daniel</span> <span class="surname">Huang</span></h3><code class="email">&lt;<a href="mailto:dhuang@jboss.org">dhuang@jboss.org</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">Mircea</span> <span class="surname">Markus</span></h3><code class="email">&lt;<a href="mailto:mircea.markus@jboss.com">mircea.markus@jboss.com</a>&gt;</code></div></div><div><p class="releaseinfo">版本 2.2.0 Poblano</p></div><div><p class="copyright">版权 © 2004, 2005, 2006, 2007, 2008 红帽子公司 JBoss 部门</p></div><div><p class="pubdate">2008 五月</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">前言</a></span></dt><dt><span class="part"><a href="#d0e123">I. JBoss Cache 简介</a></span></dt><dd><dl><dt><span class="chapter"><a href="#introduction">1. 概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e135">1.1. JBoss Cache 是什么？</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e145">1.1.1. <a href="#pojo"><em class="glossterm">Pojo</em></a> Cache 又是什么？</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e171">1.2. 功能摘要</a></span></dt><dt><span class="section"><a href="#d0e231">1.3. 
         需求
      </a></span></dt><dt><span class="section"><a href="#d0e252">1.4. 许可证</a></span></dt></dl></dd><dt><span class="chapter"><a href="#api">2. 用户 <a href="#api_gloss"><em class="glossterm">API</em></a></a></span></dt><dd><dl><dt><span class="section"><a href="#d0e274">2.1. API 类</a></span></dt><dt><span class="section"><a href="#api.create_start">2.2. 初始化和启动缓存</a></span></dt><dt><span class="section"><a href="#d0e378">2.3. 缓存数据和取回数据</a></span></dt><dt><span class="section"><a href="#basic_api.fqn">2.4. 
         <code class="literal">Fqn</code> 类
      </a></span></dt><dt><span class="section"><a href="#d0e459">2.5. 停止和撤销缓存</a></span></dt><dt><span class="section"><a href="#d0e483">2.6. 缓存模式</a></span></dt><dt><span class="section"><a href="#api.listener">2.7. 
         添加缓存监听器 - 注册缓存事件
      </a></span></dt><dt><span class="section"><a href="#d0e716">2.8. 使用缓存加载器</a></span></dt><dt><span class="section"><a href="#d0e756">2.9. 使用驱逐策略</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">3. 配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e793">3.1. 配置概述</a></span></dt><dt><span class="section"><a href="#configuration.creation">3.2. 构建一个
         <code class="literal">Configuration</code>
      </a></span></dt><dd><dl><dt><span class="section"><a href="#d0e844">3.2.1. 解析基于 XML 的配置文件</a></span></dt><dt><span class="section"><a href="#d0e882">3.2.2. 编程方法配置</a></span></dt><dt><span class="section"><a href="#d0e922">3.2.3. 使用 <a href="#ioc"><em class="glossterm">IOC</em></a> 框架</a></span></dt></dl></dd><dt><span class="section"><a href="#configuration.elements">3.3. 
         <code class="literal">Configuration</code>
         对象的组成
      </a></span></dt><dt><span class="section"><a href="#d0e1042">3.4. 动态重配置</a></span></dt><dt><span class="section"><a href="#configuration.options">3.5. 通过Option API 重新定义配置</a></span></dt></dl></dd><dt><span class="chapter"><a href="#deployment">4. 部署 JBoss Cache</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.standalone">4.1. 独立使用/编程部署</a></span></dt><dt><span class="section"><a href="#deployment.microkernel">4.2. 在 JBoss <a href="#as"><em class="glossterm">AS</em></a> （JBoss AS 5.x 和 4.x）中基于 JMX 部署</a></span></dt><dt><span class="section"><a href="#deployment.microcontainer">4.3. 通过 JBoss Microcontainer （JBoss AS 5.x）部署</a></span></dt><dt><span class="section"><a href="#d0e1282">4.4. 在 JBoss AS 中绑定到 <a href="#jndi"><em class="glossterm">JNDI</em></a></a></span></dt><dt><span class="section"><a href="#d0e1299">4.5. 运行管理信息</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx.mbeans">4.5.1. JBoss Cache MBeans</a></span></dt><dt><span class="section"><a href="#jmx.registration">4.5.2. 在 MBeanServer 中注册 CacheJmxWrapper</a></span></dt><dt><span class="section"><a href="#jmx.statistics">4.5.3. JBoss Cache 统计数据</a></span></dt><dt><span class="section"><a href="#d0e1536">4.5.4. 接受 JMX 通知</a></span></dt><dt><span class="section"><a href="#d0e1568">4.5.5. 在一个独立环境中访问缓存 MBeans</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#compatibility">5. 版本兼容性和协同工作能力</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1625">5.1. 兼容性矩阵</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#d0e1633">II. JBoss Cache 体系框架</a></span></dt><dd><dl><dt><span class="chapter"><a href="#architecture">6. 架构</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture.tree_structure">6.1. 缓存中的数据结构</a></span></dt><dt><span class="section"><a href="#architecture.SPI_interfaces">6.2. SPI 接口</a></span></dt><dt><span class="section"><a href="#architecture.invocations">6.3. Node 上的方法调用</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture.interceptors">6.3.1. 拦截器</a></span></dt><dt><span class="section"><a href="#architecture.methodcalls">6.3.2. MethodCalls</a></span></dt><dt><span class="section"><a href="#architecture.invocationcontext">6.3.3. InvocationContexts</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.managers">6.4. 子系统的管理器</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture.rpcmanager">6.4.1. RpcManager</a></span></dt><dt><span class="section"><a href="#architecture.buddymanager">6.4.2. BuddyManager</a></span></dt><dt><span class="section"><a href="#architecture.cacheloadermanager">6.4.3. CacheLoaderManager</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.marshalling">6.5. 编码和报文格式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1951">6.5.1. 编码器接口</a></span></dt><dt><span class="section"><a href="#d0e1982">6.5.2. VersionAwareMarshaller</a></span></dt><dt><span class="section"><a href="#d0e2019">6.5.3. CacheMarshaller200</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.regions">6.6. 类加载和区域</a></span></dt></dl></dd><dt><span class="chapter"><a href="#clustering">7. 集群</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2111">7.1. 缓存复制模式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2116">7.1.1. 本地模式</a></span></dt><dt><span class="section"><a href="#d0e2121">7.1.2. 复制的缓存</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2304">7.2. 失效</a></span></dt><dt><span class="section"><a href="#d0e2313">7.3. 状态传递</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2321">7.3.1. 状态传递类型</a></span></dt><dt><span class="section"><a href="#d0e2326">7.3.2. 字节数组和基于流的状态传递</a></span></dt><dt><span class="section"><a href="#d0e2333">7.3.3. 全部和部分状态传递</a></span></dt><dt><span class="section"><a href="#d0e2401">7.3.4. 暂时（“内存”）和持久状态传递</a></span></dt><dt><span class="section"><a href="#d0e2458">7.3.5. 配置状态传递</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#cache_loaders">8. 缓存加载器</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2480">8.1. CacheLoader 接口和生命周期</a></span></dt><dt><span class="section"><a href="#d0e2576">8.2. 配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2684">8.2.1. 单独存储配置</a></span></dt></dl></dd><dt><span class="section"><a href="#cl.impls">8.3. 带有的实现</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2779">8.3.1. 基于文件系统的缓存加载器</a></span></dt><dt><span class="section"><a href="#d0e2844">8.3.2. 向其他缓存委托的缓存加载器</a></span></dt><dt><span class="section"><a href="#cl.jdbc">8.3.3. JDBCCacheLoader</a></span></dt><dt><span class="section"><a href="#cl.s3">8.3.4. S3CacheLoader</a></span></dt><dt><span class="section"><a href="#cl.tcp">8.3.5. TcpDelegatingCacheLoader</a></span></dt><dt><span class="section"><a href="#cl.transforming">8.3.6. 转换缓存加载器</a></span></dt></dl></dd><dt><span class="section"><a href="#cl.pass">8.4. 缓存钝化</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3270">8.4.1. 钝化打开和关闭下缓存加载器的行为</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3300">8.5. 策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3305">8.5.1. 带有存储的本地缓存</a></span></dt><dt><span class="section"><a href="#d0e3316">8.5.2. 所有缓存共享相同存储情况下的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3338">8.5.3. 只有一个缓存带有一个存储的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3362">8.5.4. 每个缓存有它自己存储的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3405">8.5.5. 分层的缓存</a></span></dt><dt><span class="section"><a href="#d0e3425">8.5.6. 多个缓存加载器</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#eviction_policies">9. 驱逐策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3450">9.1. 驱逐策略的配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3453">9.1.1. 基本配置</a></span></dt><dt><span class="section"><a href="#d0e3476">9.1.2. 驱逐区域</a></span></dt><dt><span class="section"><a href="#d0e3532">9.1.3. 驻留节点</a></span></dt><dt><span class="section"><a href="#d0e3574">9.1.4. 编程配置</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3607">9.2. 带有的驱逐策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3610">9.2.1. LRUPolicy - 近期最少使用</a></span></dt><dt><span class="section"><a href="#d0e3638">9.2.2. FIFOPolicy - 先进，先出</a></span></dt><dt><span class="section"><a href="#d0e3658">9.2.3. MRUPolicy - 最近使用</a></span></dt><dt><span class="section"><a href="#d0e3678">9.2.4. LFUPolicy - 最少使用</a></span></dt><dt><span class="section"><a href="#d0e3708">9.2.5. ExpirationPolicy</a></span></dt><dt><span class="section"><a href="#d0e3762">9.2.6. ElementSizePolicy - 基于节点里键/值对数量驱逐</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3783">9.3. 编写你自己的驱逐策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3786">9.3.1. 驱逐策略插件设计</a></span></dt><dt><span class="section"><a href="#d0e3802">9.3.2. 实现的接口</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#transactions">10. 事务和并发</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3892">10.1. 并发访问</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3897">10.1.1. 锁</a></span></dt><dt><span class="section"><a href="#d0e3914">10.1.2. 悲观锁</a></span></dt><dt><span class="section"><a href="#d0e3981">10.1.3. 乐观锁</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4052">10.2. 事务支持</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#d0e4148">III. JBoss Cache 参考配置</a></span></dt><dd><dl><dt><span class="chapter"><a href="#configuration_reference_chapter">11. 参考配置</a></span></dt><dd><dl><dt><span class="section"><a href="#sample_xml_file">11.1. XML 配置文件例子</a></span></dt><dt><span class="section"><a href="#configuration_reference">11.2. XML 属性参考表</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jmx_reference">12. JMX 参考</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx_reference.statistics">12.1. JBoss Cache 统计数据</a></span></dt><dt><span class="section"><a href="#jmx_reference.notifications">12.2. JMX MBean 通知</a></span></dt></dl></dd></dl></dd><dt><span class="glossary"><a href="#d0e5096">术语表</a></span></dt></dl></div><div class="preface" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>前言</h2></div></div></div><p>
      这是 JBoss Cache 的官方用户指导。
      与它的伴随文档（一个<a href="#faq"><em class="glossterm">FAQ</em></a>，一个指南，以及一整套 PojoCache文档）一起，
      都可以从 JBoss Cache <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://labs.jboss.com/jbosscache">文档站点</a>免费得到。
   </p><p>
      当我们使用 JBoss Cache 这个词的时候，是指 JBoss Cache Core，
      一个树形结构的、支持集群、支持事务的缓存技术。
      Pojo Cache 也是 JBoss Cache 发布程序的一部分，但它的文档是独立的。
      （Pojo Cache 是一个面向简单 Java 对象的缓存技术，它完全能够处理对象关系，
      而且在维护这些 <a href="#pojo"><em class="glossterm">POJO</em></a> 关系的同时实现集群能力。
      请查看有关 Pojo Cache 文档，以便了解更多有关信息。）
   </p><p>
      这本书的目标读者，既包括想要用 JBoss Cache 作为他们数据库集群缓存库的开发人员，
      也包括想要基于 JBoss Cache 并扩展它功能的 <em class="glossterm">OEM</em> 厂商。
      基于这个想法，这本书分成两个主要部分，一个部分详细介绍 “用户”
      <a href="#api_gloss"><em class="glossterm">API</em></a>，
      而另一个部分深入探讨专门的主题和 JBoss Cache 架构。
   </p><p>
      一般来说，Java 编程语言的良好知识基础，以及对事务和并发线程的认识和理解，
      是阅读本书所必须的。 不期望或不需要读者预先具备 JBoss 应用服务器的知识。
   </p><p>
      想要进一步讨论，请使用 JBoss Cache 
      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://labs.jboss.com/jbosscache">Web站点</a>上
      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jboss.org/index.html?module=bb&amp;op=main&amp;c=29">用户论坛</a>连接。
      我们也提供了错误跟踪报告和功能需求的机制，
      它在 JBoss Cache <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jira.jboss.com/jira/browse/JBCACHE">JIRA 问题跟踪</a>上。
      如果你对 JBoss Cache 开发或文档翻译感兴趣，我们欢迎您的来信。
      请在
      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jboss.org/index.html?module=bb&amp;op=main&amp;c=29">用户论坛</a>
      上发布消息，或通过使用 JBoss Cache 
      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://lists.jboss.org/mailman/listinfo/jbosscache-dev">开发者邮件列表</a>
      联系我们。
   </p><p>
      这本书针对于 JBoss Cache 相同版本号的发布程序。
      它可能对旧版或更新版本的 JBoss Cache 不适用。
      很重要的一点是，你要使用的文档一定要与将要使用 JBoss Cache 版本对应。
   </p></div><div class="part" lang="zh-CN"><div class="titlepage"><div><div><h1 class="title"><a id="d0e123"/>部分 I. JBoss Cache 简介</h1></div></div></div><div class="partintro" lang="zh-CN"><div/><p>
            这个章节涵盖 JBoss Cache 的基本知识，
            基于这些知识开发者可以快速地在他们的项目中开始使用 JBoss Cache。
            这章的主要内容包括基本概念和 <a href="#api_gloss"><em class="glossterm">API</em></a>，还包括如何配置和部署的信息。
         </p><div class="toc"><p><b>目录</b></p><dl><dt><span class="chapter"><a href="#introduction">1. 概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e135">1.1. JBoss Cache 是什么？</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e145">1.1.1. <a href="#pojo"><em class="glossterm">Pojo</em></a> Cache 又是什么？</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e171">1.2. 功能摘要</a></span></dt><dt><span class="section"><a href="#d0e231">1.3. 
         需求
      </a></span></dt><dt><span class="section"><a href="#d0e252">1.4. 许可证</a></span></dt></dl></dd><dt><span class="chapter"><a href="#api">2. 用户 <a href="#api_gloss"><em class="glossterm">API</em></a></a></span></dt><dd><dl><dt><span class="section"><a href="#d0e274">2.1. API 类</a></span></dt><dt><span class="section"><a href="#api.create_start">2.2. 初始化和启动缓存</a></span></dt><dt><span class="section"><a href="#d0e378">2.3. 缓存数据和取回数据</a></span></dt><dt><span class="section"><a href="#basic_api.fqn">2.4. 
         <code class="literal">Fqn</code> 类
      </a></span></dt><dt><span class="section"><a href="#d0e459">2.5. 停止和撤销缓存</a></span></dt><dt><span class="section"><a href="#d0e483">2.6. 缓存模式</a></span></dt><dt><span class="section"><a href="#api.listener">2.7. 
         添加缓存监听器 - 注册缓存事件
      </a></span></dt><dt><span class="section"><a href="#d0e716">2.8. 使用缓存加载器</a></span></dt><dt><span class="section"><a href="#d0e756">2.9. 使用驱逐策略</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">3. 配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e793">3.1. 配置概述</a></span></dt><dt><span class="section"><a href="#configuration.creation">3.2. 构建一个
         <code class="literal">Configuration</code>
      </a></span></dt><dd><dl><dt><span class="section"><a href="#d0e844">3.2.1. 解析基于 XML 的配置文件</a></span></dt><dt><span class="section"><a href="#d0e882">3.2.2. 编程方法配置</a></span></dt><dt><span class="section"><a href="#d0e922">3.2.3. 使用 <a href="#ioc"><em class="glossterm">IOC</em></a> 框架</a></span></dt></dl></dd><dt><span class="section"><a href="#configuration.elements">3.3. 
         <code class="literal">Configuration</code>
         对象的组成
      </a></span></dt><dt><span class="section"><a href="#d0e1042">3.4. 动态重配置</a></span></dt><dt><span class="section"><a href="#configuration.options">3.5. 通过Option API 重新定义配置</a></span></dt></dl></dd><dt><span class="chapter"><a href="#deployment">4. 部署 JBoss Cache</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.standalone">4.1. 独立使用/编程部署</a></span></dt><dt><span class="section"><a href="#deployment.microkernel">4.2. 在 JBoss <a href="#as"><em class="glossterm">AS</em></a> （JBoss AS 5.x 和 4.x）中基于 JMX 部署</a></span></dt><dt><span class="section"><a href="#deployment.microcontainer">4.3. 通过 JBoss Microcontainer （JBoss AS 5.x）部署</a></span></dt><dt><span class="section"><a href="#d0e1282">4.4. 在 JBoss AS 中绑定到 <a href="#jndi"><em class="glossterm">JNDI</em></a></a></span></dt><dt><span class="section"><a href="#d0e1299">4.5. 运行管理信息</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx.mbeans">4.5.1. JBoss Cache MBeans</a></span></dt><dt><span class="section"><a href="#jmx.registration">4.5.2. 在 MBeanServer 中注册 CacheJmxWrapper</a></span></dt><dt><span class="section"><a href="#jmx.statistics">4.5.3. JBoss Cache 统计数据</a></span></dt><dt><span class="section"><a href="#d0e1536">4.5.4. 接受 JMX 通知</a></span></dt><dt><span class="section"><a href="#d0e1568">4.5.5. 在一个独立环境中访问缓存 MBeans</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#compatibility">5. 版本兼容性和协同工作能力</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1625">5.1. 兼容性矩阵</a></span></dt></dl></dd></dl></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="introduction"/>第 1 章 概述</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e135">1.1. JBoss Cache 是什么？</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e145">1.1.1. <a href="#pojo"><em class="glossterm">Pojo</em></a> Cache 又是什么？</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e171">1.2. 功能摘要</a></span></dt><dt><span class="section"><a href="#d0e231">1.3. 
         需求
      </a></span></dt><dt><span class="section"><a href="#d0e252">1.4. 许可证</a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e135"/>1.1. JBoss Cache 是什么？</h2></div></div></div><p>
         JBoss Cache 是一个树形结构的，支持集群、支持事务的缓存技术。
         对于 JBoss 应用服务器支持集群服务的几个版本来说，
         它也是除了集群 <a href="#jndi"><em class="glossterm">JNDI</em></a>、HTTP 和 EJB 会话等技术之外的另外一项骨干技术。
      </p><p>
         JBoss Cache 可以用作独立的支持事务和集群的缓存库，
         或者是一个面向对象的数据存储。
         可以将它嵌入到其他的企业级 Java 框架和应用服务器中，
         例如 BEA WebLogic，IBM WebSphere, Tomcat, Spring, Hibernate, 以及其他软件。
         它的另一个常用方式就是，独立的 Java 应用程序用它维护集群状态，
         而这些独立的 Java 应用程序并不运行在应用服务器内。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e145"/>1.1.1. <a href="#pojo"><em class="glossterm">Pojo</em></a> Cache 又是什么？</h3></div></div></div><p>
            Pojo Cache 是核心 JBoss Cache <a href="#api"><em class="glossterm">API</em></a> 的一个扩展。
            Pojo Cache 提供了额外的功能，例如：
            </p><div class="itemizedlist"><ul><li>即便经过复制或持久存储，仍能维护对象之间的引用。</li><li>细粒度控制复制，即只复制修改过的对象字段。</li><li>“弱化 API”的集群模式，即仅通过注释的方式将 <a href="#pojo"><em class="glossterm">Pojo</em></a> 注释为支持集群的。</li></ul></div><p>
         </p><p>
            Pojo Cache 拥有一套完整、独立的文档，
            包括一个用户指导、<a href="#faq"><em class="glossterm">FAQ</em></a> 和指南，
            所以在这本书中不会详细讨论 Pojo Cache 。
         </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e171"/>1.2. 功能摘要</h2></div></div></div><p>
         JBoss Cache 提供了一个简明易懂的 <a href="#api_gloss"><em class="glossterm">API</em></a>,
         可以将数据（简单的 Java 对象）放置在缓存里面，通过选择的参数进行配置。
         这些参数可以是下列的其中一项或者全部：
         </p><div class="itemizedlist"><ul><li>复制到集群中的某些或全部缓存实例。</li><li>持久存储到磁盘和（或）远程集群（远程缓存）。</li><li>当内存消耗殆尽时进行垃圾回收，
            并钝化（<a href="#passivation"><em class="glossterm">Passivation</em></a>）到磁盘而状态不丢。
            </li></ul></div><p>
         另外，JBoss Cache 提供一系列的企业级功能：
         </p><div class="itemizedlist"><ul><li>可以加入到 <a href="#jta"><em class="glossterm">JTA</em></a> 事务中
            （与符合 Java EE 标准的事务管理器协同工作）。
            </li><li>当加入到 JMX 服务器的时候，可以提供缓存状态的运行统计数据。
            </li><li>允许客户代码添加监听器，接受缓存事件通知。</li></ul></div><p>
      </p><p>缓存数据被组织成树形结构，带有一个根结点。
      树上的每个节点本质上包含一个映射结构（<a href="#map"><em class="glossterm">Map</em></a>），
      以键/值对的形式存储数据。
      对于缓存中放置对象的基本要求是，它必须实现
         <code class="literal">java.io.Serializable</code>
         接口。注意：如果是<a href="#pojo"><em class="glossterm">Pojo</em></a> Cache，则不存在这个要求。
      </p><p>JBoss Cache 可以是本地或者是复制的。本地树仅存在于建立它
      的 <a href="#jvm"><em class="glossterm">JVM</em></a> 内部，
      而复制树可以将数据的修改扩散到同一集群内的某些树或所有树。
      一个集群可以跨越网络上不同主机，或者同一个主机的不同 <a href="#jvm"><em class="glossterm">JVM</em></a> 。
      </p><p>当缓存中的对象在事务的环境下被修改了，
      那么直到事务提交成功后，修改才被复制。
      所有的修改都被保存在调用程序事务的列表里面，
      当事务提交时，我们就复制修改。
      反之，当回滚时，我们仅仅在本地取消修改，网络流量和开销是零。
      举例来说，如果调用程序做了 100 处修改，然后又回滚了事务，
      我们不会复制任何东西，所以也就没有网络流量。
      </p><p>如果调用程序没有绑定到一个事务（而且隔离层次不是 NONE，后面会详细讲解），
      每次修改都会发生复制，例如上面举的例子，我们就会发出 100 条消息，
      还要附加上额外的回滚信息。
      在这种情况下，我们认为没有事务的运行，类似于 JDBC 术语中的打开自动提交开关的运行，
      在这里每次操作自动提交。
      </p><p>
         JBoss Cache 本身能够与多数流行事务管理器协同工作，
         而且提供了一个 <a href="#api_gloss"><em class="glossterm">API</em></a>，
         可以自己编写查找事务管理器的代码。
      </p><p>
         这个缓存技术也是完全线程安全的。
         在缺省的情况下，它在树形节点上使用悲观锁方案，配置选项中也带有乐观锁方案。
         在悲观锁的情况下，通过使用一些隔离层次可以调整并发程度，
         这些隔离层次与数据库风格的事务隔离层次相对应，
         例如 SERIALIZABLE, REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITTED 和 NONE。
         同时，加锁和隔离层次在后面讨论。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e231"/>1.3. 
         需求
      </h2></div></div></div><p>
         JBoss Cache 需要 Java 5.0 （或更高版本）。
      </p><p>
         但是有一个方法可以将 JBoss Cache 构建为与 Java 1.4.x 兼容的二进制格式，
         就是用 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossRetro">JBossRetro</a>
         反向编译 Java 5.0 二进制格式。
         然而，当前红帽子公司对反向编译程序不提供专业支持，
         而且 Java 1.4.x 兼容的二进制格式并没有包含在二进制发布程序中。
         请查看
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossCacheHabaneroJava1.4">这个 wiki</a>
         页面，上面为您提供了构建反向编译程序的详细介绍。
      </p><p>
         从根本上说，除了 Java 5.0，JBoss Cache 依赖
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jgroups.org">JGroups</a>
         和 Apache 的
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/logging/">commons-logging
         </a>
         。JBoss Cache 本身带有运行所必须的依赖库。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e252"/>1.4. 许可证</h2></div></div></div><p>
         JBoss Cache 是一个开源产品，它使用
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.opensource.org/">OSI 认可的</a>
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.gnu.org/copyleft/lesser.html">LGPL 许可证</a>，
         这个许可证对商业开发和 OEM 比较友好。
         JBoss Cache 的商业开发支持、产品支持和培训可以通过
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jboss.com">红帽子公司 JBoss 部门</a>得到。
         JBoss Cache 是 JBoss 专业开源
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jboss.comindex">JEMS</a>
         （JBoss Enterprise Middleware Suite，JBoss 企业中间件套件）一部分。
      </p></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="api"/>第 2 章 用户 <a href="#api_gloss"><em class="glossterm">API</em></a></h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e274">2.1. API 类</a></span></dt><dt><span class="section"><a href="#api.create_start">2.2. 初始化和启动缓存</a></span></dt><dt><span class="section"><a href="#d0e378">2.3. 缓存数据和取回数据</a></span></dt><dt><span class="section"><a href="#basic_api.fqn">2.4. 
         <code class="literal">Fqn</code> 类
      </a></span></dt><dt><span class="section"><a href="#d0e459">2.5. 停止和撤销缓存</a></span></dt><dt><span class="section"><a href="#d0e483">2.6. 缓存模式</a></span></dt><dt><span class="section"><a href="#api.listener">2.7. 
         添加缓存监听器 - 注册缓存事件
      </a></span></dt><dt><span class="section"><a href="#d0e716">2.8. 使用缓存加载器</a></span></dt><dt><span class="section"><a href="#d0e756">2.9. 使用驱逐策略</a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e274"/>2.1. API 类</h2></div></div></div><p>
         <code class="literal">Cache</code>
         接口是与 JBoss Cache 交互的主要结构。
         使用<code class="literal">CacheFactory</code>可以构造<code class="literal">Cache</code>，
         也可以用它启动<code class="literal">Cache</code>。
         <code class="literal">CacheFactory</code>
         允许你通过<code class="literal">Configuration</code>对象或一个 XML 文件创建一个
         <code class="literal">Cache</code>。
         一旦你引用一个<code class="literal">Cache</code>实例，
         你就可以用它在树形结构里面查找<code class="literal">Node</code>对象，
         并在树形结构里面存储数据。
         </p><div class="mediaobject"><img src="PublicAPI.png"/></div><p>

      </p><p>
         查看一下上述接口的 javadoc 是学习 API 的最好方法。
         在下面文档里，我们将涵盖一些要点。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="api.create_start"/>2.2. 初始化和启动缓存</h2></div></div></div><p>
         <code class="literal">Cache</code>接口的实例只能经由
         <code class="literal">CacheFactory</code>
         创建。（这不像 JBoss Cache 1.x，旧的<code class="literal">TreeCache</code>实例可以直接初始化）
      </p><p>
         <code class="literal">CacheFactory</code> 提供一些创建 <code class="literal">Cache</code>
         的可重载方法，但是他们都做相同的事情：
         </p><div class="itemizedlist"><ul><li>或者通过传过来的方法参数，或者通过分析 XML 内容构建这两种方法，
            获得对 <code class="literal">Configuration</code> 的访问。
            XML 内容可以来自提供的一个输入流，或者一个类路径或文件系统位置。
            请查看
               <a href="#configuration" title="第 3 章 配置">有关配置的章节</a>，
               得到更多有关
               <code class="literal">Configuration</code> 的信息。
            </li><li>初始化
               <code class="literal">Cache</code>，
               并给它提供一个 <code class="literal">Configuration</code> 引用。
            </li><li>有选择地调用缓存的
               <code class="literal">create()</code>
               和
               <code class="literal">start()</code>
               方法。
            </li></ul></div><p>
      </p><p>
         下面是一个创建和启动缓存机制的最简单例子，它使用缺省的配置值：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheFactory</span><span class="java_plain">&nbsp;factory&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DefaultCacheFactory</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createCache</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>下面的例子，我们让
         <code class="literal">CacheFactory</code>
         查找和分析类路径上的一个配置文件：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheFactory</span><span class="java_plain">&nbsp;factory&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DefaultCacheFactory</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createCache</span><span class="java_separator">(</span><span class="java_literal">&quot;cache-configuration.xml&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>下面的例子，我们还是通过一个文件配置缓存，
      但是希望通过编程修改配置元素。所以，我们让工厂不要启动缓存，
      而是我们自己启动它：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheFactory</span><span class="java_plain">&nbsp;factory&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DefaultCacheFactory</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createCache</span><span class="java_separator">(</span><span class="java_literal">&quot;cache-configuration.xml&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Configuration</span><span class="java_plain">&nbsp;config&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getConfiguration</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;config</span><span class="java_separator">.</span><span class="java_plain">setClusterName</span><span class="java_separator">(</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">getClusterName</span><span class="java_separator">());</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Have</span><span class="java_plain">&nbsp;to&nbsp;create&nbsp;and&nbsp;start&nbsp;cache&nbsp;before&nbsp;using&nbsp;it</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">create</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">start</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e378"/>2.3. 缓存数据和取回数据</h2></div></div></div><p>下面，让我们使用
         <code class="literal">Cache</code>
         API 来访问一个缓存中的
         <code class="literal">Node</code>，
         并对那个节点做一些简单的读和写。
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Let</span><span class="java_plain">'s&nbsp;get&nbsp;ahold&nbsp;of&nbsp;the&nbsp;root&nbsp;node</span><span class="java_separator">.</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Node</span><span class="java_plain">&nbsp;rootNode&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getRoot</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Remember</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">JBoss</span><span class="java_plain">&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;stores&nbsp;data&nbsp;in&nbsp;a&nbsp;tree&nbsp;structure</span><span class="java_separator">.</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">All</span><span class="java_plain">&nbsp;nodes&nbsp;in&nbsp;the&nbsp;tree&nbsp;structure&nbsp;are&nbsp;identified&nbsp;by&nbsp;</span><span class="java_type">Fqn</span><span class="java_plain">&nbsp;objects</span><span class="java_separator">.</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Fqn</span><span class="java_plain">&nbsp;peterGriffinFqn&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">Fqn</span><span class="java_separator">.</span><span class="java_plain">fromString</span><span class="java_separator">(</span><span class="java_literal">&quot;/griffin/peter&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Create</span><span class="java_plain">&nbsp;a&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Node</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Node</span><span class="java_plain">&nbsp;peterGriffin&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;rootNode</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;let's&nbsp;store&nbsp;some&nbsp;data&nbsp;in&nbsp;the&nbsp;node</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;peterGriffin</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;isCartoonCharacter&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">Boolean</span><span class="java_separator">.</span><span class="java_plain">TRUE</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;peterGriffin</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;favouriteDrink&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Beer</span><span class="java_separator">());</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;some&nbsp;tests&nbsp;</span><span class="java_separator">(</span><span class="java_plain">just&nbsp;assume&nbsp;</span><span class="java_keyword">this</span><span class="java_plain">&nbsp;code&nbsp;is&nbsp;in&nbsp;a&nbsp;</span><span class="java_type">JUnit</span><span class="java_plain">&nbsp;test&nbsp;</span><span class="java_keyword">case</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertTrue</span><span class="java_separator">(</span><span class="java_plain">peterGriffin</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">&quot;isCartoonCharacter&quot;</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertEquals</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">,</span><span class="java_plain">&nbsp;peterGriffin</span><span class="java_separator">.</span><span class="java_plain">getFqn</span><span class="java_separator">());</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertTrue</span><span class="java_separator">(</span><span class="java_plain">rootNode</span><span class="java_separator">.</span><span class="java_plain">hasChild</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">));</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Set</span><span class="java_plain">&nbsp;keys&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">HashSet</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;keys</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_literal">&quot;isCartoonCharacter&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;keys</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_literal">&quot;favouriteDrink&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertEquals</span><span class="java_separator">(</span><span class="java_plain">keys</span><span class="java_separator">,</span><span class="java_plain">&nbsp;peterGriffin</span><span class="java_separator">.</span><span class="java_plain">getKeys</span><span class="java_separator">());</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;let's&nbsp;remove&nbsp;some&nbsp;data&nbsp;from&nbsp;the&nbsp;node</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;peterGriffin</span><span class="java_separator">.</span><span class="java_plain">remove</span><span class="java_separator">(</span><span class="java_literal">&quot;favouriteDrink&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertNull</span><span class="java_separator">(</span><span class="java_plain">peterGriffin</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">&quot;favouriteDrink&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;let's&nbsp;remove&nbsp;the&nbsp;node&nbsp;altogether</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;rootNode</span><span class="java_separator">.</span><span class="java_plain">removeChild</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertFalse</span><span class="java_separator">(</span><span class="java_plain">rootNode</span><span class="java_separator">.</span><span class="java_plain">hasChild</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
         <code class="literal">Cache</code> 接口以一个 <a href="#basic_api.fqn" title="2.4.  Fqn 类">Fqn</a>
         作为参数，暴露存/取/移动操作：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Fqn</span><span class="java_plain">&nbsp;peterGriffinFqn&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">Fqn</span><span class="java_separator">.</span><span class="java_plain">fromString</span><span class="java_separator">(</span><span class="java_literal">&quot;/griffin/peter&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;isCartoonCharacter&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">Boolean</span><span class="java_separator">.</span><span class="java_plain">TRUE</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;favouriteDrink&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Beer</span><span class="java_separator">());</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertTrue</span><span class="java_separator">(</span><span class="java_plain">peterGriffin</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;isCartoonCharacter&quot;</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertTrue</span><span class="java_separator">(</span><span class="java_plain">cache</span><span class="java_separator">.</span><span class="java_plain">getRootNode</span><span class="java_separator">().</span><span class="java_plain">hasChild</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">));</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">remove</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;favouriteDrink&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertNull</span><span class="java_separator">(</span><span class="java_plain">cache</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;favouriteDrink&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">removeNode</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertFalse</span><span class="java_separator">(</span><span class="java_plain">cache</span><span class="java_separator">.</span><span class="java_plain">getRootNode</span><span class="java_separator">().</span><span class="java_plain">hasChild</span><span class="java_separator">(</span><span class="java_plain">peterGriffinFqn</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="basic_api.fqn"/>2.4. 
         <code class="literal">Fqn</code> 类
      </h2></div></div></div><p>
         前一个章节在它的例子中使用了
         <code class="literal">Fqn</code> 类，现在让我们学习一些有关这个类的知识。
      </p><p>
         一个全路径名（Fully Qualified Name，Fqn）封装了缓存树结构上某一个特定位置的路径名列表。
         列表里的这些元素一般是 <code class="literal">String</code> ，但也可以是任何
         <code class="literal">Object</code> 或者不同类型的混合。
      </p><p>
         这个路径可以是绝对的（例如，相对于根节点），或者相对于缓存中的任一节点。
         阅读使用<code class="literal">Fqn</code>的 API 调用文档，
         会告诉你这个 API 是希望相对的还是绝对的 <code class="literal">Fqn</code>。
      </p><p>
         <code class="literal">Fqn</code> 类提供了多个构造子，
         查看 javadoc 了解所有的可能情况。
         下面的例子举例说明创建一个 Fqn 的最常使用方法：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Create</span><span class="java_plain">&nbsp;an&nbsp;</span><span class="java_type">Fqn</span><span class="java_plain">&nbsp;pointing&nbsp;to&nbsp;node&nbsp;</span><span class="java_literal">'Joe'</span><span class="java_plain">&nbsp;under&nbsp;parent&nbsp;node&nbsp;</span><span class="java_literal">'Smith'</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;under&nbsp;the&nbsp;</span><span class="java_literal">'people'</span><span class="java_plain">&nbsp;section&nbsp;of&nbsp;the&nbsp;tree</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Parse</span><span class="java_plain">&nbsp;it&nbsp;from&nbsp;a&nbsp;</span><span class="java_type">String</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Fqn</span><span class="java_operator">&lt;</span><span class="java_type">String</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;abc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">Fqn</span><span class="java_separator">.</span><span class="java_plain">fromString</span><span class="java_separator">(</span><span class="java_literal">&quot;/people/Smith/Joe/&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Build</span><span class="java_plain">&nbsp;it&nbsp;directly</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_type">Marginally</span><span class="java_plain">&nbsp;more&nbsp;efficient&nbsp;to&nbsp;construct&nbsp;than&nbsp;parsing</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;strings&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">String</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;people&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;Smith&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;Joe&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">};</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Fqn</span><span class="java_operator">&lt;</span><span class="java_type">String</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;abc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Fqn</span><span class="java_operator">&lt;</span><span class="java_type">String</span><span class="java_operator">&gt;</span><span class="java_separator">(</span><span class="java_plain">strings</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Here</span><span class="java_plain">&nbsp;we&nbsp;want&nbsp;to&nbsp;use&nbsp;types&nbsp;other&nbsp;than&nbsp;</span><span class="java_type">String</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Object</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;objs&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Object</span><span class="java_separator">[]{</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;accounts&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;NY&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Integer</span><span class="java_separator">(</span><span class="java_literal">12345</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">};</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Fqn</span><span class="java_operator">&lt;</span><span class="java_type">Object</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;acctFqn&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Fqn</span><span class="java_operator">&lt;</span><span class="java_type">Object</span><span class="java_operator">&gt;</span><span class="java_separator">(</span><span class="java_plain">objs</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>注意这个</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Fqn</span><!-- <br/> --><span class="java_operator">&lt;</span><!-- <br/> --><span class="java_type">String</span><!-- <br/> --><span class="java_operator">&gt;</span><!-- <br/> --><span class="java_plain">&nbsp;f&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Fqn</span><!-- <br/> --><span class="java_operator">&lt;</span><!-- <br/> --><span class="java_type">String</span><!-- <br/> --><span class="java_operator">&gt;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;/a/b/c&quot;</span><!-- <br/> --><span class="java_separator">);</span></pre><p>与下面的<span class="emphasis"><em>不同</em></span>
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Fqn</span><!-- <br/> --><span class="java_operator">&lt;</span><!-- <br/> --><span class="java_type">String</span><!-- <br/> --><span class="java_operator">&gt;</span><!-- <br/> --><span class="java_plain">&nbsp;f&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Fqn</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">fromString</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;/a/b/c&quot;</span><!-- <br/> --><span class="java_separator">);</span></pre><p>
         前者用一个简单元素构造了一个 Fqn，叫做“/a/b/c”，直接挂在缓存根下。
         后者将构建一个三个元素的 Fqn，其中“c”是“b”的子节点，
         “b”是“a”的子节点，“a”挂在缓存根结点下。
         另一个辨别方法是，只有“/”分割符作为字符串传递给
         <code class="literal">Fqn.fromString()</code>时才被解析，其他情况不解析。
      </p><p>
         1.x 版本的 JBoss Cache API 包括很多方便的重载方法，这些方法接受
         <code class="literal">/a/b/c</code> 格式的字符串，而不是一个
         <code class="literal">Fqn</code>。
         为了简化 API，在 JBC 2.x API 中没有再提供这些方便的重载方法。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e459"/>2.5. 停止和撤销缓存</h2></div></div></div><p>
         在使用完毕后，停止和撤销缓存是一个好的实践方式，
         特别是当是个集群缓存并使用了 JGroups 通道。
         停止和撤销缓存，能够保证象 JGroups 通道这类资源被正确地清理。
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">stop</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">destroy</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
         不仅缓存在调用 <code class="literal">stop()</code> 后，能通过一个新的
         <code class="literal">start()</code> 调用重新启动；类似地，
         缓存在调用
         <code class="literal">destroy()</code>后，能通过一个新的
         <code class="literal">create()</code> 调用重新创建
         （然后通过一个<code class="literal">start()</code>重新启动）。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e483"/>2.6. 缓存模式</h2></div></div></div><p>
         虽然从技术上讲这不是 API 的一部分，但是缓存配置的
         <span class="emphasis"><em>模式</em></span>将影响任何集群范围的
         <code class="literal">put</code> 和 <code class="literal">remove</code> 操作表现。
         因此，我们在这里将简明地叙述不同的模式。
      </p><p>
         JBoss Cache 模式由
         <code class="literal">org.jboss.cache.config.Configuration.CacheMode</code>
         枚举类型表示。它们包括：
         </p><div class="itemizedlist"><ul><li><span class="emphasis"><em>LOCAL</em></span>
               - 本地，非集群缓存。本地缓存不参与集群，也不同集群里的其他缓存通信。
               因此，他们的内容也不用串行化。但是，我们推荐将他们串行化，
               这样将来的某一天想要改变缓存模式时允许一定的灵活性。
            </li><li><span class="emphasis"><em>REPL_SYNC</em></span>
               - 同步复制。复制缓存将所有的变化复制到集群中的其他缓存。
               同步复制意味着，复制变化时，调用是阻塞的，直到收到复制确认。
            </li><li><span class="emphasis"><em>REPL_ASYNC</em></span>
               - 异步复制。与上面的 REPL_SYNC 类似，
               复制缓存将所有的变化复制到集群中的其他缓存。
               因为异步，调用者不用阻塞直到收到复制确认。
            </li><li><span class="emphasis"><em>INVALIDATION_SYNC</em></span>
               - 如果缓存配置为失效而不是复制，
               每次缓存里数据更新，集群里的其他缓存将收到通知消息，
               通知他们的数据已经陈旧了，应该从内存中驱逐。
               这将减少复制的开销，然而仍然能够使远程缓存中的陈旧数据失效。
            </li><li><span class="emphasis"><em>INVALIDATION_ASYNC</em></span>
               - 象上面一样，但是这个失效模式是用异步的方式广播失效消息的。
            </li></ul></div><p>
      </p><p>查看
         <a href="#clustering" title="第 7 章 集群">有关集群的章节</a>，
         了解缓存模式如何影响表现的更详细信息。
         查看
         <a href="#configuration" title="第 3 章 配置">有关配置的章节</a>，
         了解如何配置缓存模式的信息。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="api.listener"/>2.7. 
         添加缓存监听器 - 注册缓存事件
      </h2></div></div></div><p>
         JBoss Cache 提供一个注册缓存事件通知的方便机制。
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Object</span><span class="java_plain">&nbsp;myListener&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">MyCacheListener</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">addCacheListener</span><span class="java_separator">(</span><span class="java_plain">myListener</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
         移除和查询已注册监听器的方法与此类似。查看有关
         <code class="literal">Cache</code> 接口的javadoc，了解更详细内容。
      </p><p>
         基本上，任意公开类型都能用作监听器，
         只要给它添加 <code class="literal">@CacheListener</code> 注释。
         另外，这个类还需要在一个或多个方法上添加某个方法层注释（
         在 <code class="literal">org.jboss.cache.notifications.annotation</code> 包里）。
         这样的注释方法需要是 public，有一个 void 返回类型，
         并接受单一
         <code class="literal">org.jboss.cache.notifications.event.Event</code>
         类型参数或其子类。

         </p><div class="itemizedlist"><ul><li><p>
                  <code class="literal">@CacheStarted</code>
                  - 这样注释的方法，当缓存启动时接到通知。
                  方法需要接受
                  <code class="literal">CacheStartedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@CacheStopped</code>
                  - 这样注释的方法，当缓存停止时接到通知。
                  方法需要接受
                  <code class="literal">CacheStoppedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodeCreated</code>
                  - 这样注释的方法，当一个节点被构建时接到通知。
                  方法需要接受
                  <code class="literal">NodeCreatedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodeRemoved</code>
                  - 这样注释的方法，当一个节点被移除时接到通知。
                 方法需要接受
                  <code class="literal">NodeRemovedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodeModified</code>
                  - 这样注释的方法，当一个节点被修改时接到通知。
                  方法需要接受
                  <code class="literal">NodeModifiedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodeMoved</code>
                  - 这样注释的方法，当一个节点被移动时接到通知。
                  方法需要接受
                  <code class="literal">NodeMovedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodeVisited</code>
                  - 这样注释的方法，当一个节点被启动时接到通知。
                  方法需要接受
                  <code class="literal">NodeVisitedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodeLoaded</code>
                  - 这样注释的方法，当一个节点从 <code class="literal">CacheLoader</code>
                  被加载时接到通知。
                  方法需要接受
                  <code class="literal">NodeLoadedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodeEvicted</code>
                  - 这样注释的方法，当一个节点被从内存驱逐时接到通知。
                  方法需要接受
                  <code class="literal">NodeEvictedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodeActivated</code>
                  - 这样注释的方法，当一个节点被激活时接到通知。
                  方法需要接受
                  <code class="literal">NodeActivatedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@NodePassivated</code>
                  - 这样注释的方法，当一个节点被钝化时接到通知。
                  方法需要接受
                  <code class="literal">NodePassivatedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@TransactionRegistered</code>
                  - 这样注释的方法，当缓存向一个注册的事务管理器注册一个
                  <code class="literal">javax.transaction.Synchronization</code> 时接到通知。
                  方法需要接受
                  <code class="literal">TransactionRegisteredEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@TransactionCompleted</code>
                  - 这样注释的方法，当缓存从一个注册事务管理器接到提交或回滚调用时接到通知。
                  方法需要接受
                  <code class="literal">TransactionCompletedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@ViewChanged</code>
                  - 这样注释的方法，当集群修改组结构时接到通知。
                  方法需要接受
                  <code class="literal">ViewChangedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@CacheBlocked</code>
                  - 这样注释的方法，当集群因为状态转移事件要求缓存被阻塞时接到通知。
                  方法需要接受
                  <code class="literal">CacheBlockedEvent</code> 指定的参数类型。
               </p></li><li><p>
                  <code class="literal">@CacheUnblocked</code>
                  - 这样注释的方法，当集群在状态转移事件之后缓存操作已经解除阻塞时接到通知。
                  方法需要接受
                  <code class="literal">CacheUnblockedEvent</code> 指定的参数类型。
               </p></li></ul></div><p>
      </p><p>
         需要时候，参考注释的 javadoc，
         还有传递进你方法的 <code class="literal">Event</code> 子类型的详细信息。
      </p><p>
         例子：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;@</span><span class="java_type">CacheListener</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">MyListener</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">CacheStarted</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">CacheStopped</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;cacheStartStopEvent</span><span class="java_separator">(</span><span class="java_type">Event</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">switch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">e</span><span class="java_separator">.</span><span class="java_plain">getType</span><span class="java_separator">())</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">case</span><span class="java_plain">&nbsp;</span><span class="java_type">Event</span><span class="java_separator">.</span><span class="java_type">Type</span><span class="java_separator">.</span><span class="java_plain">CACHE_STARTED</span><span class="java_operator">:</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_literal">&quot;Cache&nbsp;has&nbsp;started&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">break</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">case</span><span class="java_plain">&nbsp;</span><span class="java_type">Event</span><span class="java_separator">.</span><span class="java_type">Type</span><span class="java_separator">.</span><span class="java_plain">CACHE_STOPPED</span><span class="java_operator">:</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_literal">&quot;Cache&nbsp;has&nbsp;stopped&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">break</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">NodeCreated</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">NodeRemoved</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">NodeVisited</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">NodeModified</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">NodeMoved</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;logNodeEvent</span><span class="java_separator">(</span><span class="java_type">NodeEvent</span><span class="java_plain">&nbsp;ne</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log</span><span class="java_separator">(</span><span class="java_literal">&quot;An&nbsp;event&nbsp;on&nbsp;node&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;ne</span><span class="java_separator">.</span><span class="java_plain">getFqn</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;&nbsp;has&nbsp;occured&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e716"/>2.8. 使用缓存加载器</h2></div></div></div><p>
         缓存加载器是 JBoss Cache 的一个重要组成部分。
         他们允许将节点持久化到磁盘或远程缓存集群，
         当缓存运行内存溢出时，允许钝化。
         另外，缓存加载器允许 JBoss Cache 实现“温和启动”，
         其中内存状态可以从持久存储中预先加载。
         JBoss Cache 带有几个缓存加载器实现。
         </p><div class="itemizedlist"><ul><li><code class="literal">org.jboss.cache.loader.FileCacheLoader</code>
               - 一个基本的、基于文件系统的缓存加载器，它将数据持久化到磁盘。
               不支持事务，性能也一般，但却是一个非常简单的解决方案。
               主要用于测试，不推荐在产品中使用。
            </li><li><code class="literal">org.jboss.cache.loader.JDBCCacheLoader</code>
               - 使用 <a href="#jdbc"><em class="glossterm">JDBC</em></a> 连接持久化数据。
               在一个内部连接池（使用 c3p0 连接池库）中或从配置数据源，创建和维护连接。
               缓存加载器连接的数据库位置可以是本地的或远程的。
            </li><li><code class="literal">org.jboss.cache.loader.BdbjeCacheLoader</code>
               - 使用 Oracle 的基于文件的事务数据库 BerkeleyDB 来持久化数据。
               支持事务，性能良好，但是潜在地有许可证限制。
            </li><li><code class="literal">org.jboss.cache.loader.JdbmCacheLoader</code>
               - 一个即将面世的开源 BerkeleyDB 替代品。
            </li><li><code class="literal">org.jboss.cache.loader.tcp.TcpCacheLoader</code>
               - 使用 TCP 套接字将数据“持久化”到一个远程集群。
               使用“远程缓存”模式。
               <sup>[<a id="d0e745" href="#ftn.d0e745">1</a>]</sup></li><li><code class="literal">org.jboss.cache.loader.ClusteredCacheLoader</code>
               - 用作“只读”缓存加载器，集群中的其他节点在这里查询状态。
            </li></ul></div><p>
         有关这些缓存加载器的高级主题和调整问题，在
         <a href="#cache_loaders" title="第 8 章 缓存加载器">缓存加载器专题章节</a>讨论。
         .
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e756"/>2.9. 使用驱逐策略</h2></div></div></div><p>
         驱逐策略与缓存加载器是配对出现的。它们都是保证缓存不发生内存溢出的必要条件。
         当缓存开始装填，驱逐算法在一个单独线程运行，
         将内存状态卸载到缓存加载器并且空出内存。
         驱逐策略可以基于区域配置，因此缓存中的不同子树可以有不同的驱逐参数。

         JBoss Cache 带有几个驱逐策略：
         </p><div class="itemizedlist"><ul><li><code class="literal">org.jboss.cache.eviction.LRUPolicy</code>
               - 这个驱逐策略在达到临界值时，驱逐最近最少使用的节点。
            </li><li><code class="literal">org.jboss.cache.eviction.LFUPolicy</code>
               - 这个驱逐策略在达到临界值时，驱逐不频繁使用的节点。
            </li><li><code class="literal">org.jboss.cache.eviction.MRUPolicy</code>
               - 这个驱逐策略在达到临界值时，驱逐最近最新使用的节点。
            </li><li><code class="literal">org.jboss.cache.eviction.FIFOPolicy</code>
               - 这个驱逐策略在达到临界值时，建立一个先进先出队列驱逐最旧节点。
            </li><li><code class="literal">org.jboss.cache.eviction.ExpirationPolicy</code>
               - 这个驱逐策略根据每个节点配置的过期时间驱逐节点。
            </li><li><code class="literal">org.jboss.cache.eviction.ElementSizePolicy</code>
               - 这个驱逐策略基于节点中存储的键/值对数量驱逐节点。
            </li></ul></div><p>
         详细的配置信息以及实现自定义的驱逐策略，在
         <a href="#eviction_policies" title="第 9 章 驱逐策略">驱逐策略专题章节</a>讨论。
         .
      </p></div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="footnotes"><br/><hr/><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e745" href="#d0e745">1</a>] </sup>http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossClusteringPatternFarCache</p></div></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration"/>第 3 章 配置</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e793">3.1. 配置概述</a></span></dt><dt><span class="section"><a href="#configuration.creation">3.2. 构建一个
         <code class="literal">Configuration</code>
      </a></span></dt><dd><dl><dt><span class="section"><a href="#d0e844">3.2.1. 解析基于 XML 的配置文件</a></span></dt><dt><span class="section"><a href="#d0e882">3.2.2. 编程方法配置</a></span></dt><dt><span class="section"><a href="#d0e922">3.2.3. 使用 <a href="#ioc"><em class="glossterm">IOC</em></a> 框架</a></span></dt></dl></dd><dt><span class="section"><a href="#configuration.elements">3.3. 
         <code class="literal">Configuration</code>
         对象的组成
      </a></span></dt><dt><span class="section"><a href="#d0e1042">3.4. 动态重配置</a></span></dt><dt><span class="section"><a href="#configuration.options">3.5. 通过Option API 重新定义配置</a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e793"/>3.1. 配置概述</h2></div></div></div><p>
         <code class="literal">org.jboss.cache.config.Configuration</code>
         类（以及它的 <a href="#configuration.elements" title="3.3.  Configuration 对象的组成">组件</a>）
         是一个 Java Bean，封装了 <code class="literal">Cache</code> 的配置信息以及它的所有框架元素
         （缓存加载器，驱逐策略等）。
      </p><p>
         <code class="literal">Configuration</code> 暴露很多属性，这些属性在这本书的
         <a href="#configuration_reference" title="11.2. XML 属性参考表">参考配置</a>章节总结，
         很多属性都是在后面章节讨论。
         每当你看到本书讨论的配置选项，你都可以假定
         <code class="literal">Configuration</code> 
         类或者它的组件为这个配置选项暴露一个简单的 setter/getter 属性。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration.creation"/>3.2. 构建一个
         <code class="literal">Configuration</code>
      </h2></div></div></div><p>
         在
         <a href="#api.create_start" title="2.2. 初始化和启动缓存">用户 API 部分</a>中讨论过，
         在构建 <code class="literal">Cache</code> 之前，
         必须提供一个 <code class="literal">CacheFactory</code>，
         并给<code class="literal">CacheFactory</code>一个
         <code class="literal">Configuration</code> 对象，
         <code class="literal">Configuration</code>也可以从一个文件名或输入流通过解析XML构建。
         下面的部分将讨论如果实现上述这个方法。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e844"/>3.2.1. 解析基于 XML 的配置文件</h3></div></div></div><p>
            通过一个 XML 文件来配置 JBoss Cache 是最方便的方法。
            JBoss Cache 的发布程序带有一些常用用例的配置文件。
            作为起点，推荐你使用这些文件，根据特殊需求做微调。
         </p><p>
            这有一个简单的样本配置文件：
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;=====================================================================&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;&nbsp;Sample&nbsp;JBoss&nbsp;Cache&nbsp;Service&nbsp;Configuration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;=====================================================================&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">mbean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">code</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.jmx.CacheJmxWrapper&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;jboss.cache:service=Cache&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Configure&nbsp;the&nbsp;TransactionManager&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TransactionManagerLookupClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.jboss.cache.transaction.GenericTransactionManagerLookup</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Node&nbsp;locking&nbsp;level&nbsp;:&nbsp;SERIALIZABLE</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPEATABLE_READ&nbsp;(default)</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;READ_COMMITTED</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;READ_UNCOMMITTED</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;IsolationLevel&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">READ_COMMITTED</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Lock&nbsp;parent&nbsp;before&nbsp;doing&nbsp;node&nbsp;additions/removes&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;LockParentForChildInsertRemove&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Valid&nbsp;modes&nbsp;are&nbsp;LOCAL&nbsp;(default)</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPL_ASYNC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPL_SYNC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INVALIDATION_ASYNC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INVALIDATION_SYNC&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheMode&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">LOCAL</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Max&nbsp;number&nbsp;of&nbsp;milliseconds&nbsp;to&nbsp;wait&nbsp;for&nbsp;a&nbsp;lock&nbsp;acquisition&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;LockAcquisitionTimeout&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">15000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Specific&nbsp;eviction&nbsp;policy&nbsp;configurations.&nbsp;This&nbsp;is&nbsp;LRU&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;EvictionConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;wakeUpIntervalSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;policyClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.eviction.LRUPolicy</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Cache&nbsp;wide&nbsp;default&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/_default_&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;timeToLiveSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">1000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">mbean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>
            在这本书的<a href="#sample_xml_file" title="11.1. XML 配置文件例子">参考配置</a>部分，
            包含另一个更全面的样本 XML 文件，还有一个
            <a href="#configuration_reference" title="11.2. XML 属性参考表">查找手册表</a>来解释不同的选项。
         </p><p>
            因为历史的原因，JBoss Cache 配置文件的格式遵循
            JBoss <a href="#as"><em class="glossterm">AS</em></a> 服务归档
            （Service Archive，SAR）部署描述符标准
            （还可以用于<a href="#deployment.microkernel" title="4.2. 在 JBoss AS （JBoss AS 5.x 和 4.x）中基于 JMX 部署">JBoss AS 之中</a>）。
            因为这个双重用法，你可能看见有些配置文件的元素
            （例如
            <code class="literal">depends</code>
            或
            <code class="literal">classpath</code>
            ）在 JBoss AS 之外是不相关的，这些都可以安全地被忽略。
         </p><p>
            下面代码将向你展示，如何通过查找并解析类路径上的配置文件，让
            <code class="literal">CacheFactory</code>
            构建和启动一个缓存：
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheFactory</span><span class="java_plain">&nbsp;factory&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DefaultCacheFactory</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createCache</span><span class="java_separator">(</span><span class="java_literal">&quot;cache-configuration.xml&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e882"/>3.2.2. 编程方法配置</h3></div></div></div><p>
            除了上面的基于 XML 配置方法，也可以通过编程的方式构建
            <code class="literal">Configuration</code>，
            就是用简单的改变对象属性的方法，这些方法是由
            <code class="literal">Configuration</code> 和它的组件提供的。
            当构建时，JBoss Cache 用缺省值预先设定 <code class="literal">Configuration</code>，
            可以用这些缺省设定作为快速起点。
         </p><p>
            下面是一个编程配置的例子，
            构建了一个象上面 XML 例子一样的
            <code class="literal">Configuration</code>，并用它创建了一个
            <code class="literal">Cache</code> ：
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Configuration</span><span class="java_plain">&nbsp;config&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Configuration</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;tmlc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">GenericTransactionManagerLookup</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;config</span><span class="java_separator">.</span><span class="java_plain">setTransactionManagerLookupClass</span><span class="java_separator">(</span><span class="java_plain">tmlc</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;config</span><span class="java_separator">.</span><span class="java_plain">setIsolationLevel</span><span class="java_separator">(</span><span class="java_type">IsolationLevel</span><span class="java_separator">.</span><span class="java_plain">READ_COMMITTED</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;config</span><span class="java_separator">.</span><span class="java_plain">setCacheMode</span><span class="java_separator">(</span><span class="java_type">CacheMode</span><span class="java_separator">.</span><span class="java_plain">LOCAL</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;config</span><span class="java_separator">.</span><span class="java_plain">setLockParentForChildInsertRemove</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;config</span><span class="java_separator">.</span><span class="java_plain">setLockAcquisitionTimeout</span><span class="java_separator">(</span><span class="java_literal">15000</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">EvictionConfig</span><span class="java_plain">&nbsp;ec&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">EvictionConfig</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;ec</span><span class="java_separator">.</span><span class="java_plain">setWakeupIntervalSeconds</span><span class="java_separator">(</span><span class="java_literal">5</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;ec</span><span class="java_separator">.</span><span class="java_plain">setDefaultEvictionPolicyClass</span><span class="java_separator">(</span><span class="java_type">LRUPolicy</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">());</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">EvictionRegionConfig</span><span class="java_plain">&nbsp;erc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">EvictionRegionConfig</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;erc</span><span class="java_separator">.</span><span class="java_plain">setRegionName</span><span class="java_separator">(</span><span class="java_literal">&quot;_default_&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">LRUConfiguration</span><span class="java_plain">&nbsp;lru&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">LRUConfiguration</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;lru</span><span class="java_separator">.</span><span class="java_plain">setMaxNodes</span><span class="java_separator">(</span><span class="java_literal">5000</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;lru</span><span class="java_separator">.</span><span class="java_plain">setTimeToLiveSeconds</span><span class="java_separator">(</span><span class="java_literal">1000</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;erc</span><span class="java_separator">.</span><span class="java_plain">setEvictionPolicyConfig</span><span class="java_separator">(</span><span class="java_plain">lru</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">List</span><span class="java_operator">&lt;</span><span class="java_type">EvictionRegionConfig</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;ercs&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ArrayList</span><span class="java_operator">&lt;</span><span class="java_type">EvictionRegionConfig</span><span class="java_operator">&gt;</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;ercs</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">erc</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;ec</span><span class="java_separator">.</span><span class="java_plain">setEvictionRegionConfigs</span><span class="java_separator">(</span><span class="java_plain">erc</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;config</span><span class="java_separator">.</span><span class="java_plain">setEvictionConfig</span><span class="java_separator">(</span><span class="java_plain">ec</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheFactory</span><span class="java_plain">&nbsp;factory&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DefaultCacheFactory</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createCache</span><span class="java_separator">(</span><span class="java_plain">config</span><span class="java_separator">);</span>
</pre><p>
            即便是上面这个相当简单的配置，用编程的方法也很单调乏味。
            因此，首选的配置方式还是基于 XML 的方法。
            如果你的应用程序需要这种方法，完全可以用基于 XML 的方法配置大多数属性，
            然后访问 <code class="literal">Configuration</code> 对象用编程的方法修改少部分属性的缺省值，
            例如添加一个驱逐区域。
         </p><p>
            注意：当一个缓存已经开始运行时，配置值就不可以通过编程修改了，
            但是那些注释为 <code class="literal">@Dynamic</code> 的除外。
            动态属性在 <a href="#configuration_reference" title="11.2. XML 属性参考表">参考配置</a>表中也标示出来了。
            如果要修改一个非动态属性将导致
            <code class="literal">ConfigurationException</code> 的异常。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e922"/>3.2.3. 使用 <a href="#ioc"><em class="glossterm">IOC</em></a> 框架</h3></div></div></div><p>
            <code class="literal">Configuration</code> 类和它的
            <a href="#configuration.elements" title="3.3.  Configuration 对象的组成">组件</a> 都是 Java Bean，
            他们通过简单的 getter 和 setter 方法暴露所有配置元素。
            因此，任意好的 IOC 框架都能够构从一个自己格式的 XML 文件构建一个
            <code class="literal">Configuration</code>。
            查看
            <a href="#deployment.microcontainer" title="4.3. 通过 JBoss Microcontainer （JBoss AS 5.x）部署">通过 JBoss 微容器部署</a>
            章节中的相关例子。
         </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration.elements"/>3.3. 
         <code class="literal">Configuration</code>
         对象的组成
      </h2></div></div></div><p>
         一个
         <code class="literal">Configuration</code> 由几个子对象组成：

         </p><div class="mediaobject"><img src="Configuration.png"/></div><p>
      </p><p>
         下面是
         <code class="literal">Configuration</code> 组件的简短概述。
         查看 javadoc 和本书章节的连接，了解每个组件配置的更加完整解释。

         </p><div class="itemizedlist"><ul><li><code class="literal">Configuration</code>
               : 层次结构的顶层对象，本书
               <a href="#configuration_reference" title="11.2. XML 属性参考表">参考配置</a>
               一章列出的配置属性都由它提供给你。
            </li><li><code class="literal">BuddyReplicationConfig</code>
               : 只有在使用
               <a href="#br" title="7.1.2.2. 伙伴复制">伙伴复制</a>的情况下，这个配置才生效。
               它是伙伴复制的通用配置选项，必须包括一个：
            </li><li><code class="literal">BuddyLocatorConfig</code>
               : 服务于所用<code class="literal">BuddyLocator</code>实现，
               是一个与特定实现有关配置对象。
               依据 <code class="literal">BuddyLocator</code> 实现的需求，来决定暴露什么配置元素。
            </li><li><code class="literal">EvictionConfig</code>
               : 只有在使用
               <a href="#eviction_policies" title="第 9 章 驱逐策略">驱逐</a>的情况下，这个配置生效。
               它是驱逐配置的通用选项，必须包括至少一个：
            </li><li><code class="literal">EvictionRegionConfig</code>
               : 每个驱逐区域一个，为区域命名。必须包括一个：
            </li><li><code class="literal">EvictionPolicyConfig</code>
               : 服务于所用<code class="literal">EvictionPolicy</code>实现，
               是一个与特定实现有关配置对象。
               依据<code class="literal">EvictionPolicy</code>实现的需求，来决定暴露什么配置元素。
            </li><li><code class="literal">CacheLoaderConfig</code>
               : 只有在使用
               <a href="#cache_loaders" title="第 8 章 缓存加载器">缓存加载器</a>的情况下，这个配置生效。
               它是缓存加载器配置的通用选项，必须包括至少一个：
            </li><li><code class="literal">IndividualCacheLoaderConfig</code>
               : 服务于所用<code class="literal">CacheLoader</code>实现，
               是一个与特定实现有关配置对象。
               依据<code class="literal">CacheLoader</code>实现的需求，来决定暴露什么配置元素。
            </li><li><code class="literal">RuntimeConfig</code>
               : 向每个缓存客户端暴露有关缓存运行环境的某些信息
               （例如，如果使用<a href="#br" title="7.1.2.2. 伙伴复制">伙伴缓存</a>，
               暴露伙伴缓存组的成员）。
               也允许直接注入缓存需要的外部服务，象一个
               <a href="#jta"><em class="glossterm">JTA</em></a> 的
               <code class="literal">TransactionManager</code> 或者
               一个 JGroups 的
               <code class="literal">ChannelFactory</code>。
            </li></ul></div><p>
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1042"/>3.4. 动态重配置</h2></div></div></div><p>
         当缓存运行时，是支持动态修改
         <span class="emphasis"><em>某些</em></span>配置选项的。
         例如，通过从正在运行的缓存得到
         <code class="literal">Configuration</code> 对象，然后通过编程修改相关值。
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Configuration</span><span class="java_plain">&nbsp;liveConfig&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getConfiguration</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;liveConfig</span><span class="java_separator">.</span><span class="java_plain">setLockAcquisitionTimeout</span><span class="java_separator">(</span><span class="java_literal">2000</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
         在
         <a href="#configuration_reference" title="11.2. XML 属性参考表">参考配置</a>章节中，
         有一个可动态修改选项的完整列表。
         如果你试图修改一个不能动态修改的选项，将会抛出一个
         <code class="literal">org.jboss.cache.config.ConfigurationException</code> 异常。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration.options"/>3.5. 通过Option API 重新定义配置</h2></div></div></div><p>
         Option API 允许你在每次调用前，重新定义缓存的某些状态。
         这个步骤包括，创建一个
         <code class="literal">org.jboss.cache.config.Option</code> 实例，
         在
         <code class="literal">Option</code> 上设置你想重新定义的选项，
         然后在调用缓存方法前将它传递给
         <code class="literal">InvocationContext</code>。
      </p><p>
         例如，用乐观锁重新定义缺省的节点版本控制：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">DataVersion</span><span class="java_plain">&nbsp;v&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">MyCustomDataVersion</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getInvocationContext</span><span class="java_separator">().</span><span class="java_plain">getOptionOverrides</span><span class="java_separator">().</span><span class="java_plain">setDataVersion</span><span class="java_separator">(</span><span class="java_plain">v</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Node</span><span class="java_plain">&nbsp;ch&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getRoot</span><span class="java_separator">().</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_type">Fqn</span><span class="java_separator">.</span><span class="java_plain">fromString</span><span class="java_separator">(</span><span class="java_literal">&quot;/a/b/c&quot;</span><span class="java_separator">));</span>
</pre><p>
         例如，在一个 REPL_SYNC 缓存中，禁止添加调用的复制：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Node</span><span class="java_plain">&nbsp;node&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getChild</span><span class="java_separator">(</span><span class="java_type">Fqn</span><span class="java_separator">.</span><span class="java_plain">fromString</span><span class="java_separator">(</span><span class="java_literal">&quot;/a/b/c&quot;</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getInvocationContext</span><span class="java_separator">().</span><span class="java_plain">getOptionOverrides</span><span class="java_separator">().</span><span class="java_plain">setLocalOnly</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;node</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;localCounter&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Integer</span><span class="java_separator">(</span><span class="java_literal">2</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
         查看
         <code class="literal">Option</code> 类的 javadoc，了解有关可用选项的详细情况。
      </p></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="deployment"/>第 4 章 部署 JBoss Cache</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#deployment.standalone">4.1. 独立使用/编程部署</a></span></dt><dt><span class="section"><a href="#deployment.microkernel">4.2. 在 JBoss <a href="#as"><em class="glossterm">AS</em></a> （JBoss AS 5.x 和 4.x）中基于 JMX 部署</a></span></dt><dt><span class="section"><a href="#deployment.microcontainer">4.3. 通过 JBoss Microcontainer （JBoss AS 5.x）部署</a></span></dt><dt><span class="section"><a href="#d0e1282">4.4. 在 JBoss AS 中绑定到 <a href="#jndi"><em class="glossterm">JNDI</em></a></a></span></dt><dt><span class="section"><a href="#d0e1299">4.5. 运行管理信息</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx.mbeans">4.5.1. JBoss Cache MBeans</a></span></dt><dt><span class="section"><a href="#jmx.registration">4.5.2. 在 MBeanServer 中注册 CacheJmxWrapper</a></span></dt><dt><span class="section"><a href="#jmx.statistics">4.5.3. JBoss Cache 统计数据</a></span></dt><dt><span class="section"><a href="#d0e1536">4.5.4. 接受 JMX 通知</a></span></dt><dt><span class="section"><a href="#d0e1568">4.5.5. 在一个独立环境中访问缓存 MBeans</a></span></dt></dl></dd></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="deployment.standalone"/>4.1. 独立使用/编程部署</h2></div></div></div><p>
         当在一个独立的 Java 程序中使用时，
         所要做的事情就是用
         <code class="literal">CacheFactory</code> 
         和一个
         <code class="literal">Configuration</code> 实例或一个 XML 文件初始化缓存。
         其中配置实例或 XML 文件的配置方法，在
         <a href="#api.create_start" title="2.2. 初始化和启动缓存">用户 API</a>
         和
         <a href="#configuration.creation" title="3.2. 构建一个 Configuration">配置</a>中章节讨论过。
      </p><p>
         当应用程序在一个应用服务器中运行，
         同时想要通过编程的方式部署缓存而不是依赖应用服务器的部署功能，
         也可以用与上述技术相同的技术来完成。
         这种方法的例子就是，一个 Web 应用通过
         <code class="literal">javax.servlet.ServletContextListener</code> 部署一个缓存。
      </p><p>
         如果部署后，希望通过 <a href="#jmx"><em class="glossterm">JMX</em></a> 方式暴露一个管理接口，可以查看
         <a href="#jmx.registration.programatic" title="4.5.2.1. 编程注册">有关在 JMX 中编程注册的章节</a>。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="deployment.microkernel"/>4.2. 在 JBoss <a href="#as"><em class="glossterm">AS</em></a> （JBoss AS 5.x 和 4.x）中基于 JMX 部署</h2></div></div></div><p>如果 JBoss Cache 是在 JBoss AS 中运行，
      那么可以简单地将缓存部署成一个 MBean，
      方法是将一个标准的缓存配置文件拷贝到服务器的
         <code class="literal">deploy</code> 目录。
         标准格式的 JBoss Cache 标准 XML 配置文件（参见
         <a href="#sample_xml_file" title="11.1. XML 配置文件例子">参考配置</a>）
         与 JBoss AS MBean 部署描述符相同，
         因此 AS 的<a href="#sar"><em class="glossterm">SAR</em></a> 部署器处理起来没有任何问题。
         同时，你不必一定要将配置文件放在
         <code class="literal">deploy</code>目录下，
         你可以将它与其他服务或 JEE 组件打包在 SAR 或 EAR 里面。
      </p><p>
         在 AS 5 里面，如果是基于标准的<code class="literal">all</code>配置使用一个服务器，
         那么这就是你需要做的全部事情了，因为所有需要的 jar 都在类路径上了。
         其他情况下，你需要保证
         <code class="literal">jbosscache.jar</code>
         和
         <code class="literal">jgroups-all.jar</code>
         在你的类路径上。
         如果你使用 <code class="literal">JdbmCacheLoader</code> 之类的功能，
         你可能需要添加其他的 jar。
         最简单的做法是，将 JBoss Cache 发布程序
         <code class="literal">lib</code> 目录下的 jar 拷贝到服务器的
         <code class="literal">lib</code> 配置目录下。
         你也可以将配置文件和 jar 都打包成到服务归档（.sar）文件或一个 EAR 里面。
      </p><p>
         将 JBoss Cache 2.0 实例部署到 JBoss AS 4.x 是可行的
         （至少是 4.2.0.GA，其他 AS 版本没有经过充分测试）。
         但是，JBoss Cache 2.x 版本 和 1.x 版本之间 API 的变化还是很大的，
         这就意味着依赖 JBoss Cache 的标准 AS 4.x 集群服务
         （例如http session 复制）都不能与 JBoss Cache 2.x 协同工作。
         也要意识到，JBoss Cache 的开发人员没有充分测试在 AS 4.x 中使用 JBoss Cache 2.x 的情况。
         因此，你自己要保证充分测试你的应用程序（总之，这当然是你正在做的）。
      </p><p>
         注意，在
         <a href="#sample_xml_file" title="11.1. XML 配置文件例子">例子</a>中，
         <code class="literal">mbean</code> 元素值的
         <code class="literal">code</code> 属性：
         <code class="literal">org.jboss.cache.jmx.CacheJmxWrapper</code>，
         这是 JBoss Cache 使用的处理 JMX 集成的类。
         <code class="literal">Cache</code> 自己并不暴露一个 MBean 接口。
         查看
         <a href="#jmx.mbeans" title="4.5.1. JBoss Cache MBeans">JBoss Cache MBeans 章节</a>，
         了解有关 <code class="literal">CacheJmxWrapper</code> 更详细内容。
      </p><p>
         一旦你的缓存部署好了，为了 VM 内的客户，例如一个 servlet，使用它，
         可以用一个 JMX 代理得到缓存的引用：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">MBeanServer</span><span class="java_plain">&nbsp;server&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">MBeanServerLocator</span><span class="java_separator">.</span><span class="java_plain">locateJBoss</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;jboss.cache:service=Cache&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheJmxWrapperMBean</span><span class="java_plain">&nbsp;cacheWrapper&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">(</span><span class="java_type">CacheJmxWrapperMBean</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_type">MBeanServerInvocationHandler</span><span class="java_separator">.</span><span class="java_plain">newProxyInstance</span><span class="java_separator">(</span><span class="java_plain">server</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">,</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheJmxWrapperMBean</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;cacheWrapper</span><span class="java_separator">.</span><span class="java_plain">getCache</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Node</span><span class="java_plain">&nbsp;root&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getRoot</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;etc&nbsp;etc</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span></pre><p>MBeanServerLocator 类是一个在当前 JVM 中查找 JBoss MBean 服务的辅助工具。
      <code class="literal">javax.management.MBeanServerInvocationHandler</code> 类的
      <code class="literal">newProxyInstance</code> 方法创建一个指定接口的动态代理实现，
      并基于 MBean 产生接口用 JMX 去动态匹配方法调用。
      用于查找 MBean 的名称与缓存配置文件里定义的名称是相同的。
      </p><p>
         一旦获得 <code class="literal">CacheJmxWrapper</code> 的代理，
         <code class="literal">getCache()</code> 将返回
         <code class="literal">Cache</code> 自身的一个引用。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="deployment.microcontainer"/>4.3. 通过 JBoss Microcontainer （JBoss AS 5.x）部署</h2></div></div></div><p>
         从 AS 5 开始，JBoss AS 也支持部署 <a href="#pojo"><em class="glossterm">POJO</em></a> 服务，
         方法是部署一个文件名用
         <code class="literal">-beans.xml</code> 结尾的文件。
         一个 POJO 服务是一个用 “简单 Java 对象（Plain Old Java Object）”实现的服务，
         这意味着简单 Java Bean 不需要实现某一特定接口或扩展某一特定超类。
         一个 <code class="literal">Cache</code> 就是一个 POJO 服务，所有
         <code class="literal">Configuration</code> 里的组件也是 POJO。
         因此，用这种方法部署缓存很自然。
      </p><p>
         部署缓存是通过使用 JBoss Microcontainer 完成，
         JBoss Microcontainer 形成了 JBoss AS 的核心。
         JBoss Microcontainer 是一个成熟的 IOC 框架（类似于 Spring）。
         从根本上说，一个 <code class="literal">-beans.xml</code> 文件就是一个描述符，
         这个描述符告诉 IOC 框架如何将不同 Bean 组装起来形成一个 POJO 服务。
      </p><p>
         对于每个
         <code class="literal">Configuration</code> 组件暴露的配置选项，
         配置类里都定义了 getter/setter。
         这么做是必须的，以便于当配置对应属性时，
         JBoss Microcontainer 能够用典型的 IOC 方式调用这些方法。
      </p><p>
         如何部署文件、如何打包、如何确保需要的 jar 在类路径上等等的规则，
         都与
         <a href="#deployment.microkernel" title="4.2. 在 JBoss AS （JBoss AS 5.x 和 4.x）中基于 JMX 部署">基于 JMX 部署</a>相同。
      </p><p>
         下面是一个例子 <code class="literal">-beans.xml</code> 文件。
         如果你在 AS 5 的
         <code class="literal">server/all/deploy</code> 安装目录下查找，
         你能找到更多例子。
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">deployment</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">xmlns</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;urn:jboss:bean-deployer:2.0&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;First&nbsp;we&nbsp;create&nbsp;a&nbsp;Configuration&nbsp;object&nbsp;for&nbsp;the&nbsp;cache&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCacheConfig&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.config.Configuration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Externally&nbsp;injected&nbsp;services&nbsp;--&gt;</span><span class="xml_plain">&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;runtimeConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCacheRuntimeConfig&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.config.RuntimeConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;transactionManager&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">inject</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">bean</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;jboss:service=TransactionManager&quot;</span><span class="xml_plain">&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">property</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TransactionManager&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;muxChannelFactory&quot;</span><span class="xml_tag_symbols">&gt;&lt;</span><span class="xml_tag_name">inject</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">bean</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;JChannelFactory&quot;</span><span class="xml_tag_symbols">/&gt;&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;multiplexerStack&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">udp</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;clusterName&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">Example-EntityCache</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;locking&nbsp;level&nbsp;:&nbsp;SERIALIZABLE</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPEATABLE_READ&nbsp;(default)</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;READ_COMMITTED</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;READ_UNCOMMITTED</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NONE</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;isolationLevel&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">REPEATABLE_READ</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Valid&nbsp;modes&nbsp;are&nbsp;LOCAL</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPL_ASYNC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPL_SYNC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cacheMode&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">REPL_SYNC</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;&nbsp;The&nbsp;max&nbsp;amount&nbsp;of&nbsp;time&nbsp;(in&nbsp;milliseconds)&nbsp;we&nbsp;wait&nbsp;until&nbsp;the</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial&nbsp;state&nbsp;(ie.&nbsp;the&nbsp;contents&nbsp;of&nbsp;the&nbsp;cache)&nbsp;are&nbsp;retrieved&nbsp;from</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;existing&nbsp;members&nbsp;in&nbsp;a&nbsp;clustered&nbsp;environment</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;initialStateRetrievalTimeout&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">15000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;milliseconds&nbsp;to&nbsp;wait&nbsp;until&nbsp;all&nbsp;responses&nbsp;for&nbsp;a</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronous&nbsp;call&nbsp;have&nbsp;been&nbsp;received.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;syncReplTimeout&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">20000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;&nbsp;Max&nbsp;number&nbsp;of&nbsp;milliseconds&nbsp;to&nbsp;wait&nbsp;for&nbsp;a&nbsp;lock&nbsp;acquisition&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;lockAcquisitionTimeout&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">15000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;exposeManagementStatistics&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Must&nbsp;be&nbsp;true&nbsp;if&nbsp;any&nbsp;entity&nbsp;deployment&nbsp;uses&nbsp;a&nbsp;scoped&nbsp;classloader&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;useRegionBasedMarshalling&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Must&nbsp;match&nbsp;the&nbsp;value&nbsp;of&nbsp;&quot;useRegionBasedMarshalling&quot;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;inactiveOnStartup&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;&nbsp;Specific&nbsp;eviction&nbsp;policy&nbsp;configurations.&nbsp;This&nbsp;is&nbsp;LRU&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;evictionConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleEvictionConfig&quot;</span><span class="xml_plain">&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.config.EvictionConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;defaultEvictionPolicyClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.jboss.cache.eviction.LRUPolicy</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;wakeupIntervalSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;evictionRegionConfigs&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">list</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleDefaultEvictionRegionConfig&quot;</span><span class="xml_plain">&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.config.EvictionRegionConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;regionName&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">/_default_</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;evictionPolicyConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleDefaultLRUConfig&quot;</span><span class="xml_plain">&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.eviction.LRUConfiguration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;timeToLiveSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">1000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">list</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Factory&nbsp;to&nbsp;build&nbsp;the&nbsp;Cache.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DefaultCacheFactory&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.DefaultCacheFactory&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">constructor</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">factoryClass</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.DefaultCacheFactory&quot;</span><span class="xml_plain">&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">factoryMethod</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;getInstance&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;The&nbsp;cache&nbsp;itself&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCache&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.Cache&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">constructor</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">factoryMethod</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;createCache&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">factory</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">bean</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DefaultCacheFactory&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">parameter</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.config.Configuration&quot;</span><span class="xml_tag_symbols">&gt;&lt;</span><span class="xml_tag_name">inject</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">bean</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCacheConfig&quot;</span><span class="xml_tag_symbols">/&gt;&lt;/</span><span class="xml_tag_name">parameter</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">parameter</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;boolean&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">false</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">constructor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">deployment</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
</pre><p>
         查看 JBoss Microcontainer 的文档
         <sup>[<a id="d0e1255" href="#ftn.d0e1255">2</a>]</sup>，
         了解上述语法的细节。
         从根本上说，每个 <code class="literal">bean</code> 元素代表一个对象，
         大多数元素一起构建一个
         <code class="literal">Configuration</code>
         和它的
         <a href="#configuration.elements" title="3.3.  Configuration 对象的组成">组件</a>。
      </p><p>
         需要注意的一件有趣事情是，在上面的例子中使用了
         <code class="literal">RuntimeConfig</code> 对象。
         外部的资源，象
         <code class="literal">TransactionManager</code>
         和 JGroups 的
         <code class="literal">ChannelFactory</code>，凡是对 microcontainer 可见的，
         都可以插入 <code class="literal">RuntimeConfig</code>。
         假定条件就是，这里引用的 Bean 在 AS 的其他部署描述符中描述了。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1282"/>4.4. 在 JBoss AS 中绑定到 <a href="#jndi"><em class="glossterm">JNDI</em></a></h2></div></div></div><p>
         在 1.x 版本的 JBoss Cache 中，缓存的代理可以绑定到 JBoss AS 的 JNDI 树上，
         这是通过使用 AS 的 <code class="literal">JRMPProxyFactory</code> 服务完成的。
         在 JBoss Cache 2.x 中，这么做不行了。
         另一个达到相同效果的方法正在由JBoss AS 组
         <sup>[<a id="d0e1292" href="#ftn.d0e1292">3</a>]</sup> 开发，是由象一个
         <code class="literal">Cache</code> 一样的一个POJO （例如，不基于 JMX）服务实现，。
         在撰写本文时，这个功能还没有完成，但它在发布 AS 5.0.0.GA 版本之前会完成。
         一旦能用时，我们会添加一个 wiki 页来描绘如何使用它。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1299"/>4.5. 运行管理信息</h2></div></div></div><p>JBoss Cache 通过 JMX MBeans 来暴露缓存功能，
      并提供用于分析缓存操作的统计信息。
      JBoss Cache 也可以将缓存事件广播为 MBean 通知，通过 JMX 监视工具来处理。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="jmx.mbeans"/>4.5.1. JBoss Cache MBeans</h3></div></div></div><p>
            JBoss Cache 提供一个 MBean，这个 MBean 可以注册在你的 JMX 服务器环境中，
            允许通过 JMX 访问缓存实例。
            这个 MBean 是
            <code class="literal">org.jboss.cache.jmx.CacheJmxWrapper</code>。
            它是一个 StandardMBean，因此它的 MBean 接口是
            <code class="literal">org.jboss.cache.jmx.CacheJmxWrapperMBean</code>。
            这个 MBean 可以用于：
            </p><div class="itemizedlist"><ul><li>得到一个底层
                  <code class="literal">Cache</code>的引用。
               </li><li>调用底层
                  <code class="literal">Cache</code> 的 create/start/stop/destroy 生命周期操作。
               </li><li>检查缓存当前状态的不同详细情况（节点数，加锁信息等）。
               </li><li>查看缓存配置的众多详细信息，并当缓存启动后修改其中那些能够修改的配置信息。
               </li></ul></div><p>
            查看 <code class="literal">CacheJmxWrapperMBean</code> 的 javadoc 了解更详细信息。
         </p><p>
            需要重点关注的是，JBoss Cache 1.x 版本和 2.x 版本之间体系结构的显著差别。
            在 1.x 版本中，旧的 <code class="literal">TreeCache</code> 类本身自己就是一个 MBean，
            基本上通过 JMX 暴露了整个缓存 API。
            在 2.x 版本中，JMX 回归到作为管理层的基础角色。
            <code class="literal">Cache</code> 对象本身完全不知道 JMX 的存在，
            反倒是为了这个目的通过一个包装类添加 JMX 功能。
            而且，通过 JMX 暴露的接口仅限于管理功能，
            普通的 <code class="literal">Cache</code> API 不在通过 JMX 暴露。
            例如，不可能通过 JMX 接口调用缓存的
            <code class="literal">put</code>
            或
            <code class="literal">get</code> 方法。
         </p><p>
            如果注册一个 <code class="literal">CacheJmxWrapper</code>，
            JBoss Cache 也为缓存拦截器堆栈中配置的每个拦截器提供 MBeans。
            这些 MBeans 用于获得和输出有关缓存操作的统计数据。
            它们与 <code class="literal">CacheJmxWrapper</code> MBean 分层关联，
            并有反应关系的服务名称。
            例如，一个
            <code class="literal">jboss.cache:service=TomcatClusteringCache</code>
            实例的复制拦截器 MBean，
            可以通过服务名
            <code class="literal">jboss.cache:service=TomcatClusteringCache,cache-interceptor=ReplicationInterceptor</code>
            访问。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="jmx.registration"/>4.5.2. 在 MBeanServer 中注册 CacheJmxWrapper</h3></div></div></div><p>
            在 JMX 中，确保 <code class="literal">CacheJmxWrapper</code> 已经注册的最佳方法，
            与如何部署你的缓存有关：
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="jmx.registration.programatic"/>4.5.2.1. 编程注册</h4></div></div></div><p>
               最简单的做法是创建你的 <code class="literal">Cache</code>，
               并将它传递给 <code class="literal">CacheJmxWrapper</code> 构造器。
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheFactory</span><span class="java_plain">&nbsp;factory&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DefaultCacheFactory</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Build</span><span class="java_plain">&nbsp;but&nbsp;don't&nbsp;start&nbsp;the&nbsp;cache</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">although&nbsp;it&nbsp;would&nbsp;work&nbsp;OK&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;we&nbsp;started&nbsp;it</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createCache</span><span class="java_separator">(</span><span class="java_literal">&quot;cache-configuration.xml&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheJmxWrapperMBean</span><span class="java_plain">&nbsp;wrapper&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheJmxWrapper</span><span class="java_separator">(</span><span class="java_plain">cache</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">MBeanServer</span><span class="java_plain">&nbsp;server&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;getMBeanServer</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;however&nbsp;you&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;it</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;jboss.cache:service=TreeCache&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">wrapper</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Invoking</span><span class="java_plain">&nbsp;lifecycle&nbsp;methods&nbsp;on&nbsp;the&nbsp;wrapper&nbsp;results</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;in&nbsp;a&nbsp;call&nbsp;through&nbsp;to&nbsp;the&nbsp;cache</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">create</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">start</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;use&nbsp;the&nbsp;cache</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;on&nbsp;application&nbsp;shutdown</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Invoking</span><span class="java_plain">&nbsp;lifecycle&nbsp;methods&nbsp;on&nbsp;the&nbsp;wrapper&nbsp;results</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;in&nbsp;a&nbsp;call&nbsp;through&nbsp;to&nbsp;the&nbsp;cache</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">stop</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">destroy</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
               另外，也可以构造一个 <code class="literal">Configuration</code> 对象，
               并把它传递给 <code class="literal">CacheJmxWrapper</code>。
               包装器会创建 <code class="literal">Cache</code>：
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Configuration</span><span class="java_plain">&nbsp;config&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;buildConfiguration</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;whatever&nbsp;it&nbsp;does</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">CacheJmxWrapperMBean</span><span class="java_plain">&nbsp;wrapper&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheJmxWrapper</span><span class="java_separator">(</span><span class="java_plain">config</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">MBeanServer</span><span class="java_plain">&nbsp;server&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;getMBeanServer</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;however&nbsp;you&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;it</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;jboss.cache:service=TreeCache&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">wrapper</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Call</span><span class="java_plain">&nbsp;to&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">create</span><span class="java_separator">()</span><span class="java_plain">&nbsp;will&nbsp;build&nbsp;the&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;one&nbsp;wasn't&nbsp;injected</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">create</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">start</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Now</span><span class="java_plain">&nbsp;that&nbsp;it's&nbsp;built</span><span class="java_separator">,</span><span class="java_plain">&nbsp;created&nbsp;and&nbsp;started</span><span class="java_separator">,</span><span class="java_plain">&nbsp;get&nbsp;the&nbsp;cache&nbsp;from&nbsp;the&nbsp;wrapper</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">getCache</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;use&nbsp;the&nbsp;cache</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;on&nbsp;application&nbsp;shutdown</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">stop</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;wrapper</span><span class="java_separator">.</span><span class="java_plain">destroy</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1399"/>4.5.2.2. 在 JBoss AS （JBoss AS 4.x 和 5.x）中基于 JMX 部署</h4></div></div></div><p>
               当你
               <a href="#deployment.microkernel" title="4.2. 在 JBoss AS （JBoss AS 5.x 和 4.x）中基于 JMX 部署">用一个 -service.xml 文件在 JBoss AS 中部署你的缓存时</a>，
               会自动注册一个 <code class="literal">CacheJmxWrapper</code>。
               不需要做其他事情。
               <code class="literal">CacheJmxWrapper</code> 可以通过缓存配置文件中
               <code class="literal">mbean</code> 元素的服务名，从一个 MBean 服务器访问。
            </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1416"/>4.5.2.3. 通过 JBoss Microcontainer （JBoss AS 5.x）部署</h4></div></div></div><p>
               <code class="literal">CacheJmxWrapper</code> 是一个 POJO，
               因此，Microcontainer 构建它没有问题。
               窍门就是在 JMX 中注册你的 Bean。
               这可以通过在<code class="literal">CacheJmxWrapper</code> bean 上指定
               <code class="literal">org.jboss.aop.microcontainer.aspects.jmx.JMX</code>
               注释来完成：
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">deployment</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">xmlns</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;urn:jboss:bean-deployer:2.0&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;First&nbsp;we&nbsp;create&nbsp;a&nbsp;Configuration&nbsp;object&nbsp;for&nbsp;the&nbsp;cache&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCacheConfig&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.config.Configuration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;build&nbsp;up&nbsp;the&nbsp;Configuration</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Factory&nbsp;to&nbsp;build&nbsp;the&nbsp;Cache.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DefaultCacheFactory&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.DefaultCacheFactory&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">constructor</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">factoryClass</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.DefaultCacheFactory&quot;</span><span class="xml_plain">&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">factoryMethod</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;getInstance&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;The&nbsp;cache&nbsp;itself&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCache&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.CacheImpl&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">constructor</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">factoryMethod</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;createnewInstance&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">factory</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">bean</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DefaultCacheFactory&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">parameter</span><span class="xml_tag_symbols">&gt;&lt;</span><span class="xml_tag_name">inject</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">bean</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCacheConfig&quot;</span><span class="xml_tag_symbols">/&gt;&lt;/</span><span class="xml_tag_name">parameter</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">parameter</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">false</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">constructor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;JMX&nbsp;Management&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCacheJmxWrapper&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.jmx.CacheJmxWrapper&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">annotation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">@org.jboss.aop.microcontainer.aspects.jmx.JMX(name=&quot;jboss.cache:service=ExampleTreeCache&quot;,&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exposedInterface=org.jboss.cache.jmx.CacheJmxWrapperMBean.class,&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;registerDirectly=true)</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">annotation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">constructor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">parameter</span><span class="xml_tag_symbols">&gt;&lt;</span><span class="xml_tag_name">inject</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">bean</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCache&quot;</span><span class="xml_tag_symbols">/&gt;&lt;/</span><span class="xml_tag_name">parameter</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">constructor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">deployment</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
</pre><p>
               象在
               <a href="#jmx.registration.programatic" title="4.5.2.1. 编程注册">编程注册</a>
               章节中讨论的一样，如果提供一个 <code class="literal">Configuration</code>，
               <code class="literal">CacheJmxWrapper</code> 可以完成建立、创建和启动
               <code class="literal">Cache</code>的工作。
               在 Microcontainer 中，这是首选的方法，因为这节省了创建
               <code class="literal">CacheFactory</code> 所需样本 XML 的工作：
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">deployment</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">xmlns</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;urn:jboss:bean-deployer:2.0&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;First&nbsp;we&nbsp;create&nbsp;a&nbsp;Configuration&nbsp;object&nbsp;for&nbsp;the&nbsp;cache&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCacheConfig&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.config.Configuration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;build&nbsp;up&nbsp;the&nbsp;Configuration</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">bean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCache&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.jmx.CacheJmxWrapper&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">annotation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">@org.jboss.aop.microcontainer.aspects.jmx.JMX(name=&quot;jboss.cache:service=ExampleTreeCache&quot;,&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exposedInterface=org.jboss.cache.jmx.CacheJmxWrapperMBean.class,&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;registerDirectly=true)</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">annotation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">constructor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">parameter</span><span class="xml_tag_symbols">&gt;&lt;</span><span class="xml_tag_name">inject</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">bean</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ExampleCacheConfig&quot;</span><span class="xml_tag_symbols">/&gt;&lt;/</span><span class="xml_tag_name">parameter</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">constructor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">bean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">deployment</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
</pre></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="jmx.statistics"/>4.5.3. JBoss Cache 统计数据</h3></div></div></div><p>
            JBoss Cache 在它的拦截器中获得统计数据，并通过拦截器 MBean 输出统计数据。
            缺省的情况下，收集统计数据的开关是打开的，
            对于某一指定缓存实例，它也可以通过
            <code class="literal">ExposeManagementStatistics</code> 配置属性关闭。
            注意，主要的统计数据是通过
            <code class="literal">CacheMgmtInterceptor</code> 提供的，
            因此，从这个角度讲这个 MBean 是最重要的。
            如果你因为性能原因想关闭所有统计数据，
            你可以将 <code class="literal">ExposeManagementStatistics</code> 设为
            <code class="literal">false</code>，在缓存启动时这将阻止缓存拦截堆栈包含
            <code class="literal">CacheMgmtInterceptor</code>。
         </p><p>
            如果在 JMX 中注册了一个 <code class="literal">CacheJmxWrapper</code>，
            包装器也保证为每个输出统计信息的拦截器在 JMX 中注册一个 MBean
            <sup>[<a id="d0e1476" href="#ftn.d0e1476">4</a>]</sup>。
            这样，管理工具可以访问这些 MBeans，来检查统计数据。
            查看
            <a href="#jmx_reference.statistics" title="12.1. JBoss Cache 统计数据">JMX 参考章节</a>中有关统计数据的部分，
            这些统计数据是通过 JMX 得到的。
         </p><p>
            注册的拦截器 MBeans 的名字是从 <code class="literal">CacheJmxWrapper</code> 注册的
            <code class="literal">ObjectName</code> 导出的，
            并添加了 <code class="literal">cache-interceptor</code> 属性键，
            这个属性键是拦截器类的非全名。
            因此，例如，如果 <code class="literal">CacheJmxWrapper</code> 的注册名是
            <code class="literal">jboss.cache:service=TreeCache</code>，
            <code class="literal">CacheMgmtInterceptor</code> MBean 名就是
            <code class="literal">jboss.cache:service=TreeCache,cache-interceptor=CacheMgmtInterceptor</code>。
         </p><p>
            每个拦截器的 MBean 暴露一个 <code class="literal">StatisticsEnabled</code> 属性，
            可以用于关闭这个拦截器的保持统计功能。
            另外，每个拦截器 MBean 提供下列通用操作和属性：
            </p><div class="itemizedlist"><ul><li><code class="literal">dumpStatistics</code>
                  - 返回一个
                  <code class="literal">Map</code>，包含拦截器的属性和值。
               </li><li><code class="literal">resetStatistics</code>
                  - 重设拦截器维护的所有统计信息。
               </li><li><code class="literal">setStatisticsEnabled(boolean)</code>
                  - 允许关闭某一拦截器的统计功能。
               </li></ul></div><p>
         </p><p>
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1536"/>4.5.4. 接受 JMX 通知</h3></div></div></div><p>
            JBoss Cache 用户可以注册一个监听器，来接受先前
            <a href="#api.listener" title="2.7.  添加缓存监听器 - 注册缓存事件">用户 API</a> 章节描述的缓存事件。
            用户可以选择利用缓存管理信息基础结构，通过 JMX 通知来接受这些事件。
            通过为 <code class="literal">CacheJmxWrapper</code> 注册一个
            <code class="literal">NotificationListener</code>，
            就可以用通知来得到缓存事件。
         </p><p>
            查看
            <a href="#jmx_reference.notifications" title="12.2. JMX MBean 通知">JMX 参考章节</a>里有关 JMX 通知的部分，
            那里有能通过
            <code class="literal">CacheJmxWrapper</code> 来接受的通知列表。
         </p><p>
            下面是一个例子，介绍当在 JBoss AS 环境中运行时，如何通过编程接受缓存通知。
            在这个例子中，客户用一个过滤器指定感兴趣的事件。
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">MyListener</span><span class="java_plain">&nbsp;listener&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">MyListener</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">NotificationFilterSupport</span><span class="java_plain">&nbsp;filter&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;get&nbsp;reference&nbsp;to&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;server</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Context</span><span class="java_plain">&nbsp;ic&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">MBeanServerConnection</span><span class="java_plain">&nbsp;server&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">MBeanServerConnection</span><span class="java_separator">)</span><span class="java_plain">ic</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;jmx/invoker/RMIAdaptor&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;get&nbsp;reference&nbsp;to&nbsp;</span><span class="java_type">CacheMgmtInterceptor</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;cache_service&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;jboss.cache:service=TomcatClusteringCache&quot;</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;mgmt_name&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_plain">cache_service</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;configure&nbsp;a&nbsp;filter&nbsp;to&nbsp;only&nbsp;receive&nbsp;node&nbsp;created&nbsp;and&nbsp;removed&nbsp;events</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;filter&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">NotificationFilterSupport</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;filter</span><span class="java_separator">.</span><span class="java_plain">disableAllTypes</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;filter</span><span class="java_separator">.</span><span class="java_plain">enableType</span><span class="java_separator">(</span><span class="java_type">CacheNotificationBroadcaster</span><span class="java_separator">.</span><span class="java_plain">NOTIF_NODE_CREATED</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;filter</span><span class="java_separator">.</span><span class="java_plain">enableType</span><span class="java_separator">(</span><span class="java_type">CacheNotificationBroadcaster</span><span class="java_separator">.</span><span class="java_plain">NOTIF_NODE_REMOVED</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;register&nbsp;the&nbsp;listener&nbsp;with&nbsp;a&nbsp;filter</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;leave&nbsp;the&nbsp;filter&nbsp;</span><span class="java_literal">null</span><span class="java_plain">&nbsp;to&nbsp;receive&nbsp;all&nbsp;cache&nbsp;events</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;server</span><span class="java_separator">.</span><span class="java_plain">addNotificationListener</span><span class="java_separator">(</span><span class="java_plain">mgmt_name</span><span class="java_separator">,</span><span class="java_plain">&nbsp;listener</span><span class="java_separator">,</span><span class="java_plain">&nbsp;filter</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;on&nbsp;completion&nbsp;of&nbsp;processing</span><span class="java_separator">,</span><span class="java_plain">&nbsp;unregister&nbsp;the&nbsp;listener</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;server</span><span class="java_separator">.</span><span class="java_plain">removeNotificationListener</span><span class="java_separator">(</span><span class="java_plain">mgmt_name</span><span class="java_separator">,</span><span class="java_plain">&nbsp;listener</span><span class="java_separator">,</span><span class="java_plain">&nbsp;filter</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>下面是在上一个例子使用的，简单通知监听器实现的代码。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">MyListener</span><span class="java_plain">&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">NotificationListener</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">Serializable</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;handleNotification</span><span class="java_separator">(</span><span class="java_type">Notification</span><span class="java_plain">&nbsp;notification</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">Object</span><span class="java_plain">&nbsp;handback</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;message&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;notification</span><span class="java_separator">.</span><span class="java_plain">getMessage</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;type&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;notification</span><span class="java_separator">.</span><span class="java_plain">getType</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Object</span><span class="java_plain">&nbsp;userData&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;notification</span><span class="java_separator">.</span><span class="java_plain">getUserData</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">type&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;:&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;message</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">userData&nbsp;</span><span class="java_operator">==</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_literal">&quot;notification&nbsp;data&nbsp;is&nbsp;null&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">else</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">userData&nbsp;</span><span class="java_keyword">instanceof</span><span class="java_plain">&nbsp;</span><span class="java_type">String</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_literal">&quot;notification&nbsp;data:&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_separator">)</span><span class="java_plain">&nbsp;userData</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">else</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">userData&nbsp;</span><span class="java_keyword">instanceof</span><span class="java_plain">&nbsp;</span><span class="java_type">Object</span><span class="java_separator">[])</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Object</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;ud&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Object</span><span class="java_separator">[])</span><span class="java_plain">&nbsp;userData</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Object</span><span class="java_plain">&nbsp;data&nbsp;</span><span class="java_operator">:</span><span class="java_plain">&nbsp;ud</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_literal">&quot;notification&nbsp;data:&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;data</span><span class="java_separator">.</span><span class="java_plain">toString</span><span class="java_separator">());</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">else</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_literal">&quot;notification&nbsp;data&nbsp;class:&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;userData</span><span class="java_separator">.</span><span class="java_plain">getClass</span><span class="java_separator">().</span><span class="java_plain">getName</span><span class="java_separator">());</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>注意：只有客户注册接受 MBean 通知后，JBoss Cache 管理实现才监听缓存事件。
         一旦没有客户注册接受通知，MBean 将去掉自己作为缓存监听器的角色。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1568"/>4.5.5. 在一个独立环境中访问缓存 MBeans</h3></div></div></div><p>
            在一个支持 MBean 服务接口的应用服务器中运行缓存实例时，例如 JBoss JMX 控制台，
            很容易访问 JBoss Cache MBeans。
            参考你的服务器文档，查找如果访问服务器 MBean 容器中运行的 MBean的相关介绍。
         </p><p>
            另外，虽然在非服务器环境中运行，如果 JVM 是 JDK 5.0 或更高，JBoss Cache MBeans 也可以访问到。
            当在 JDK 5.0 环境中运行一个独立的缓存，你可以象下面这样访问缓存 MBeans。
         </p><p>
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li>
                  当启动缓存运行的 JVM 时，设定系统属性
                  <code class="literal">-Dcom.sun.management.jmxremote</code>。
               </li><li>
                  一旦 JVM 运行起来，启动 JDK 5.0 <code class="literal">jconsole</code> 工具，
                  它在你的 JDK 的 <code class="literal">/bin</code> 目录下。
               </li><li>当工具加载后，你就能够选择你的运行 JVM 并连接它。
               在 MBean 面板处，你能得到 JBoss Cache MBeans。
               </li></ol></div><p>
         </p><p>注意：当连接到运行 JBoss Cache 实例的 JVM 时，
         <code class="literal">jconsole</code> 工具自动注册为缓存通知的监听器。
         </p><p>下面的图显示 <code class="literal">jconsole</code> 中的缓存拦截器 MBeans。
          显示<code class="literal">CacheMgmtInterceptor</code> 的缓存统计数据：
         </p><div class="figure"><a id="d0e1607"/><div class="figure-contents"><div class="mediaobject"><img src="CacheMgmtInterceptor.png" alt="jconsole 中的 CacheMgmtInterceptor MBean"/></div></div><p class="title"><b>图 4.1. jconsole 中的 CacheMgmtInterceptor MBean</b></p></div><br class="figure-break"/></div></div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="footnotes"><br/><hr/><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e1255" href="#d0e1255">2</a>] </sup>http://labs.jboss.com/jbossmc/docs</p></div><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e1292" href="#d0e1292">3</a>] </sup>http://jira.jboss.com/jira/browse/JBAS-4456</p></div><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e1476" href="#d0e1476">4</a>] </sup>
                  注意：如果 <code class="literal">CacheJmxWrapper</code> 没有在 JMX 中注册，
                  拦截器 MBeans 也就没有注册。
                  JBoss Cache 1.4 版本包括试图“发现”一个
                  <code class="literal">MBeanServer</code> 的代码，
                  并自动用它注册拦截器 MBeans。
                  在 JBoss Cache 2.x 版本中，我们决定这种“发现”JMX环境的功能已经超出了缓冲库的正常范围，
                  所以，我们去掉了这个功能。
               </p></div></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="compatibility"/>第 5 章 版本兼容性和协同工作能力</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1625">5.1. 兼容性矩阵</a></span></dt></dl></div><p>
      在一个主版本内部，JBoss Cache 是要兼容的，并能协同工作。
      就兼容性的意义而言，应用程序从一个版本到另一个版本的升级可以简单地替换 jar。
      就协同工作能力的意义而言，如果集群中用了两个不同版本的 JBoss Cache，
      它们应该能够交换复制和状态转移信息。
      但是注意：这种协同工作能力需要在集群所有节点上使用相同的 JGroups 版本。
      在大多数情况下，JBoss Cache 使用的 JGroups 版本能够升级。
   </p><p>
      就这点而论，JBoss Cache 2.x.x 与先前的 1.x.x 版本从 API 或二进制两个角度都是不兼容的。
      但是，JBoss Cache 2.1.x 与 2.0.x 是 API 和二进制兼容的。
   </p><p>
      可以用配置属性 <code class="literal">ReplicationVersion</code> 来控制缓存内部通信的报文格式。
      当与较低版本对话时，它们可以从更高效率和较新协议上转回到“兼容”版本。
      这种机制允许我们通过使用更有效率的报文格式提高 JBoss Cache，
      同时还提供了保护协同工作能力的方法。
   </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1625"/>5.1. 兼容性矩阵</h2></div></div></div><p>
         在 JBoss Cache 的 Web 站点上维护一个
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://labs.jboss.com/portal/jbosscache/compatibility/index.html">兼容性矩阵</a>，
         那里包含了有关不同版本 JBoss Cache, JGroups 和 JBoss AS 的信息。
      </p></div></div></div><div class="part" lang="zh-CN"><div class="titlepage"><div><div><h1 class="title"><a id="d0e1633"/>部分 II. JBoss Cache 体系框架</h1></div></div></div><div class="partintro" lang="zh-CN"><div/><p>
            这个章节将深入探讨 JBoss Cache 体系框架，
            目标读者是那些想要扩展或提高 JBoss Cache 的开发人员。
            基于这章内容，他们可以编写插件，或者查找框架下如何运转的更详细知识。
         </p><div class="toc"><p><b>目录</b></p><dl><dt><span class="chapter"><a href="#architecture">6. 架构</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture.tree_structure">6.1. 缓存中的数据结构</a></span></dt><dt><span class="section"><a href="#architecture.SPI_interfaces">6.2. SPI 接口</a></span></dt><dt><span class="section"><a href="#architecture.invocations">6.3. Node 上的方法调用</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture.interceptors">6.3.1. 拦截器</a></span></dt><dt><span class="section"><a href="#architecture.methodcalls">6.3.2. MethodCalls</a></span></dt><dt><span class="section"><a href="#architecture.invocationcontext">6.3.3. InvocationContexts</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.managers">6.4. 子系统的管理器</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture.rpcmanager">6.4.1. RpcManager</a></span></dt><dt><span class="section"><a href="#architecture.buddymanager">6.4.2. BuddyManager</a></span></dt><dt><span class="section"><a href="#architecture.cacheloadermanager">6.4.3. CacheLoaderManager</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.marshalling">6.5. 编码和报文格式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1951">6.5.1. 编码器接口</a></span></dt><dt><span class="section"><a href="#d0e1982">6.5.2. VersionAwareMarshaller</a></span></dt><dt><span class="section"><a href="#d0e2019">6.5.3. CacheMarshaller200</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.regions">6.6. 类加载和区域</a></span></dt></dl></dd><dt><span class="chapter"><a href="#clustering">7. 集群</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2111">7.1. 缓存复制模式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2116">7.1.1. 本地模式</a></span></dt><dt><span class="section"><a href="#d0e2121">7.1.2. 复制的缓存</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2304">7.2. 失效</a></span></dt><dt><span class="section"><a href="#d0e2313">7.3. 状态传递</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2321">7.3.1. 状态传递类型</a></span></dt><dt><span class="section"><a href="#d0e2326">7.3.2. 字节数组和基于流的状态传递</a></span></dt><dt><span class="section"><a href="#d0e2333">7.3.3. 全部和部分状态传递</a></span></dt><dt><span class="section"><a href="#d0e2401">7.3.4. 暂时（“内存”）和持久状态传递</a></span></dt><dt><span class="section"><a href="#d0e2458">7.3.5. 配置状态传递</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#cache_loaders">8. 缓存加载器</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2480">8.1. CacheLoader 接口和生命周期</a></span></dt><dt><span class="section"><a href="#d0e2576">8.2. 配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2684">8.2.1. 单独存储配置</a></span></dt></dl></dd><dt><span class="section"><a href="#cl.impls">8.3. 带有的实现</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2779">8.3.1. 基于文件系统的缓存加载器</a></span></dt><dt><span class="section"><a href="#d0e2844">8.3.2. 向其他缓存委托的缓存加载器</a></span></dt><dt><span class="section"><a href="#cl.jdbc">8.3.3. JDBCCacheLoader</a></span></dt><dt><span class="section"><a href="#cl.s3">8.3.4. S3CacheLoader</a></span></dt><dt><span class="section"><a href="#cl.tcp">8.3.5. TcpDelegatingCacheLoader</a></span></dt><dt><span class="section"><a href="#cl.transforming">8.3.6. 转换缓存加载器</a></span></dt></dl></dd><dt><span class="section"><a href="#cl.pass">8.4. 缓存钝化</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3270">8.4.1. 钝化打开和关闭下缓存加载器的行为</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3300">8.5. 策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3305">8.5.1. 带有存储的本地缓存</a></span></dt><dt><span class="section"><a href="#d0e3316">8.5.2. 所有缓存共享相同存储情况下的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3338">8.5.3. 只有一个缓存带有一个存储的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3362">8.5.4. 每个缓存有它自己存储的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3405">8.5.5. 分层的缓存</a></span></dt><dt><span class="section"><a href="#d0e3425">8.5.6. 多个缓存加载器</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#eviction_policies">9. 驱逐策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3450">9.1. 驱逐策略的配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3453">9.1.1. 基本配置</a></span></dt><dt><span class="section"><a href="#d0e3476">9.1.2. 驱逐区域</a></span></dt><dt><span class="section"><a href="#d0e3532">9.1.3. 驻留节点</a></span></dt><dt><span class="section"><a href="#d0e3574">9.1.4. 编程配置</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3607">9.2. 带有的驱逐策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3610">9.2.1. LRUPolicy - 近期最少使用</a></span></dt><dt><span class="section"><a href="#d0e3638">9.2.2. FIFOPolicy - 先进，先出</a></span></dt><dt><span class="section"><a href="#d0e3658">9.2.3. MRUPolicy - 最近使用</a></span></dt><dt><span class="section"><a href="#d0e3678">9.2.4. LFUPolicy - 最少使用</a></span></dt><dt><span class="section"><a href="#d0e3708">9.2.5. ExpirationPolicy</a></span></dt><dt><span class="section"><a href="#d0e3762">9.2.6. ElementSizePolicy - 基于节点里键/值对数量驱逐</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3783">9.3. 编写你自己的驱逐策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3786">9.3.1. 驱逐策略插件设计</a></span></dt><dt><span class="section"><a href="#d0e3802">9.3.2. 实现的接口</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#transactions">10. 事务和并发</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3892">10.1. 并发访问</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3897">10.1.1. 锁</a></span></dt><dt><span class="section"><a href="#d0e3914">10.1.2. 悲观锁</a></span></dt><dt><span class="section"><a href="#d0e3981">10.1.3. 乐观锁</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4052">10.2. 事务支持</a></span></dt></dl></dd></dl></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>第 6 章 架构</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#architecture.tree_structure">6.1. 缓存中的数据结构</a></span></dt><dt><span class="section"><a href="#architecture.SPI_interfaces">6.2. SPI 接口</a></span></dt><dt><span class="section"><a href="#architecture.invocations">6.3. Node 上的方法调用</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture.interceptors">6.3.1. 拦截器</a></span></dt><dt><span class="section"><a href="#architecture.methodcalls">6.3.2. MethodCalls</a></span></dt><dt><span class="section"><a href="#architecture.invocationcontext">6.3.3. InvocationContexts</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.managers">6.4. 子系统的管理器</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture.rpcmanager">6.4.1. RpcManager</a></span></dt><dt><span class="section"><a href="#architecture.buddymanager">6.4.2. BuddyManager</a></span></dt><dt><span class="section"><a href="#architecture.cacheloadermanager">6.4.3. CacheLoaderManager</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.marshalling">6.5. 编码和报文格式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1951">6.5.1. 编码器接口</a></span></dt><dt><span class="section"><a href="#d0e1982">6.5.2. VersionAwareMarshaller</a></span></dt><dt><span class="section"><a href="#d0e2019">6.5.3. CacheMarshaller200</a></span></dt></dl></dd><dt><span class="section"><a href="#architecture.regions">6.6. 类加载和区域</a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="architecture.tree_structure"/>6.1. 缓存中的数据结构</h2></div></div></div><p>
         一个 <code class="literal">Cache</code> 由一组 <code class="literal">Node</code> 的实例组成，
         这些 <code class="literal">Node</code> 按树型结构组织起来。
         每个 <code class="literal">Node </code> 包含一个用于缓存数据对象的 <code class="literal">Map</code>。
         需要重点关注的是，这个结构是一个数学树而不是图；
         每个 <code class="literal">Node</code>有且仅有一个父节点，
         而根节点则固定不变地被命名为 <code class="literal">Fqn.ROOT</code>。
      </p><p>
         像这样组织节点的原因是，可以提高数据的并发访问，并能在更细粒度上实现复制和持久化。
      </p><p>
         </p><div class="figure"><a id="d0e1672"/><div class="figure-contents"><div class="mediaobject"><img src="TreeCacheArchitecture.png" alt="树型数据结构"/></div></div><p class="title"><b>图 6.1. 树型数据结构</b></p></div><p><br class="figure-break"/>
         上图中每个方框表示一个JVM。
         可以看出，在独立的 JVM 中一共有两个缓存，互相复制数据。
         这些 VM 可以在同一个物理的机器上，也可以分属于通过网络相连的两台不同机器上。
         网络节点间的底层分组通讯由 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jgroups.org">JGroups</a> 实现。
      </p><p>在一个缓存实例中的任意修改（参见<a href="#api" title="第 2 章 用户 API">API 章节</a>）都将会被复制到另外一个缓存上。
      当然，在一个集群中可能会有不止两个缓存。
      依据具体的事务设置，这个复制过程可以发生在每次修改之后，也可以发生在事务结尾的提交时。
      当创建一个新的缓存后，启动时它可以选择在从一个已经存在的缓存中获取数据。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="architecture.SPI_interfaces"/>6.2. SPI 接口</h2></div></div></div><p>
         除了常用的 <code class="literal">Cache</code> 和 <code class="literal">Node</code> 接口，
         JBoss Cache还提供了更强大的 <code class="literal">CacheSPI</code>
         和 <code class="literal">NodeSPI</code> 接口，
         它们可以提供对 JBoss Cache 内部的更多控制。
         设计这些接口的目的不是为了一般应用，
         主要是为那些希望对 JBoss Cache 进行扩展和功能增强的人准备的，
         或者是那些编写自定义 <code class="literal">Interceptor</code>
         和 <code class="literal">CacheLoader</code> 实例的人。
      </p><div class="figure"><a id="d0e1710"/><div class="figure-contents"><div class="mediaobject"><img src="SPI.png" alt="SPI接口"/></div></div><p class="title"><b>图 6.2. SPI接口</b></p></div><br class="figure-break"/><p>
        不能创建 <code class="literal">CacheSPI</code> 接口，
        只能通过<code class="literal">Interceptor</code> 和 <code class="literal">CacheLoader</code> 接口的 
         <code class="literal">setCache(CacheSPI Cache)</code> 方法，注入到这些实现中。
         <code class="literal">CacheSPI</code> 是 <code class="literal">Cache</code>的扩展，
         因此对它来说，所有基本的 API 功能都是可用的。
      </p><p>
         同样的，不能创建 <code class="literal">NodeSPI</code> 接口，
         只能是通过象上面的<code class="literal">CacheSPI</code>那样的操作来获得。例如：
         <code class="literal">Cache.getRoot() : Node</code>重载为
         <code class="literal">CacheSPI.getRoot() : NodeSPI</code>。
      </p><p>
        特别要注意的是，不推荐直接将 <code class="literal">Cache</code>
         或者 <code class="literal">Node</code> 转换成对应的 SPI 对象，这种做法是很槽糕的。
         因为这种做法在日后对接口的继承进行扩展时并不能保证可用。
         换句话说，使用暴露出来的公用 API 才是有保证的做法。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="architecture.invocations"/>6.3. Node 上的方法调用</h2></div></div></div><p>
        由于缓存本质上就是节点的集合，因此对于整个缓存或其中的单个节点的调用，
        就集中在对节点的集群、持久化、驱逐等方面。
        为了用一种清晰的、模块化的、可扩展的方式实现这个目的，使用了拦截器链。
        这个链是由一系列拦截器组成，每个拦截器增加某一方面或特定功能。
        当创建缓存时，也基于使用的配置构建这个链。
      </p><p>
         特别要注意的是，<code class="literal">NodeSPI</code> 提供了一些方法（诸如
         <code class="literal">xxxDirect()</code> 方法族）直接对节点进行操作而不通过拦截器堆栈。
         使用这些方法的插件作者，应该注意到它们对缓存诸如锁、复制等等这些方面的影响。
         一般说来，除非你<span class="emphasis"><em>真的</em></span>了解你在做什么，否则不要使用这些方法！
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="architecture.interceptors"/>6.3.1. 拦截器</h3></div></div></div><p>
            <code class="literal">Interceptor</code> 是个抽象类，几个拦截器组成一个拦截器链。
            它暴露一个 <code class="literal">invoke()</code> 方法，
            这个方法由实现类来重载，在其中添加操作，
            然后通过调用 <code class="literal">super.invoke()</code> 将调用沿着链传递下去。
         </p><div class="figure"><a id="d0e1788"/><div class="figure-contents"><div class="mediaobject"><img src="Interceptor.png" alt="SPI 接口"/></div></div><p class="title"><b>图 6.3. SPI 接口</b></p></div><br class="figure-break"/><p>
            JBoss Cache 带有几个拦截器，代表不同的配置选项，其中的一些是：
            </p><div class="itemizedlist"><ul><li><code class="literal">TxInterceptor</code>
                  - 用事务管理器查找正在进行的事务和注册器，以便于参与同步事件。
               </li><li><code class="literal">ReplicationInterceptor</code>
                  - 使用 JGroups 通道，横跨集群复制状态。
               </li><li><code class="literal">CacheLoaderInterceptor</code>
                  - 如果所需数据没有在内存里，从持久存储加载数据。
               </li></ul></div><p>
            通过调用
            <code class="literal">CacheSPI.getInterceptorChain()</code>
            来获得和检查你缓存实例配置的拦截器链，
            这个方法返回一个排序的拦截器 <code class="literal">List</code>。
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="architecture.custom_interceptors"/>6.3.1.1. 编写自定义拦截器</h4></div></div></div><p>
               通过扩展
               <code class="literal">Interceptor</code> 并重载 <code class="literal">invoke()</code>，
               可以编写自定义拦截器来添加特定功能和特点。
               需要通过使用 <code class="literal">CacheSPI.addInterceptor()</code> 方法，
               将自定义拦截器添加到拦截器链中。
            </p><p>
               目前，还不支持通过 XML 方式添加自定义拦截器。
            </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="architecture.methodcalls"/>6.3.2. MethodCalls</h3></div></div></div><p>
            <code class="literal">org.jboss.cache.marshall.MethodCall</code> 是一个封装
            <code class="literal">java.lang.reflection.Method</code> 的类，
            并用一个 <code class="literal">Object[]</code> 表达方法参数。
            它是 <code class="literal">org.jgroups.blocks.MethodCall</code> 类的一个扩展，
            添加了用幻数和方法标示鉴别已知方法的机制，
            这使编码和解组更加高效和表现更佳。
         </p><p>
            这是 <code class="literal">Interceptor</code> 框架的核心，
            并且是传递给 <code class="literal">Interceptor.invoke()</code> 的唯一参数。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="architecture.invocationcontext"/>6.3.3. InvocationContexts</h3></div></div></div><p>
            <code class="literal">InvocationContext</code> 在单一调用期间保留中间状态，
            它由位于链起点的
            <code class="literal">InvocationContextInterceptor</code> 创建和销毁。
         </p><p>
            <code class="literal">InvocationContext</code> 就像它的名字暗示的一样，
            保留单一缓存方法调用的相关环境信息。
            环境信息包括关联的
            <code class="literal">javax.transaction.Transaction</code>
            或
            <code class="literal">org.jboss.cache.transaction.GlobalTransaction</code>，
            方法调用的源点（<code class="literal">InvocationContext.isOriginLocal()</code>），
            还有 <a href="#configuration.options" title="3.5. 通过Option API 重新定义配置">
                重定义的<code class="literal">Option</code>
            </a>。
         </p><p>
            通过调用 <code class="literal">Cache.getInvocationContext()</code> 获得
            <code class="literal">InvocationContext</code>。
         </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="architecture.managers"/>6.4. 子系统的管理器</h2></div></div></div><p>
         某些方法和功能是由不止一个拦截器共享，其中一部分已经封装成管理器，
         由不同拦截器调用，通过 <code class="literal">CacheSPI</code> 接口获得。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="architecture.rpcmanager"/>6.4.1. RpcManager</h3></div></div></div><p>
            这个类负责管理所有通过 JGroups 通道对远程缓存进行的
            <a href="#rpc"><em class="glossterm">RPC</em></a> 调用，
            并且封装使用的 JGroups 通道。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="architecture.buddymanager"/>6.4.2. BuddyManager</h3></div></div></div><p>
            这个类管理伙伴分组，并通过调用分组组织的远程方法，
            将集群中缓存组织成更小一点的分组。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="architecture.cacheloadermanager"/>6.4.3. CacheLoaderManager</h3></div></div></div><p>
            安装、配置缓存加载器。这个类将单个的
            <code class="literal">CacheLoader</code> 实例包装进委派类，
            例如
            <code class="literal">SingletonStoreCacheLoader</code>
            或
            <code class="literal">AsyncCacheLoader</code>
            ，或者通过使用
            <code class="literal">ChainingCacheLoader</code>也可以将
            <code class="literal">CacheLoader</code> 
            添加到链中。
         </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="architecture.marshalling"/>6.5. 编码和报文格式</h2></div></div></div><p>
         在复制过程中，JBoss Cache 的较早版本简单地通过写入一个
         <code class="literal">ObjectOutputStream</code> 来将缓存数据写入网络。
         经过 JBoss Cache 1.x.x 系列的几个版本，这个方法渐渐被弃用，
         取而代之的是一个更成熟的编码框架。
         在 JBoss Cache 2.x.x 系列中，这是官方支持和推荐将对象写入数据流的唯一机制。
      </p><div class="figure"><a id="d0e1945"/><div class="figure-contents"><div class="mediaobject"><img src="Marshaller.png" alt="编码器接口"/></div></div><p class="title"><b>图 6.4. 编码器接口</b></p></div><br class="figure-break"/><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1951"/>6.5.1. 编码器接口</h3></div></div></div><p>
            <code class="literal">Marshaller</code> 接口扩展来自 JGroups 的
            <code class="literal">RpcDispatcher.Marshaller</code>。
            这个接口有两个主要实现，一个委派
            <code class="literal">VersionAwareMarshaller</code>
            和一个具体实现
            <code class="literal">CacheMarshaller200</code>。
         </p><p>
            通过调用
            <code class="literal">CacheSPI.getMarshaller()</code> 得到编码器，
            缺省是 <code class="literal">VersionAwareMarshaller</code>。
            用户也可以通过实现 <code class="literal">Marshaller</code> 接口编写他们自己的编码器，
            然后通过 <code class="literal">MarshallerClass</code> 配置属性将他们添加进配置。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1982"/>6.5.2. VersionAwareMarshaller</h3></div></div></div><p>
            就像名字暗示的，当写操作的时候这个编码器在每个流的前面添加一个
            <code class="literal">短</code> 版本信息，
            使相同的
            <code class="literal">VersionAwareMarshaller</code> 实例能读这个短版本信息，
            并知道是那个特定编码器实现委派了这个调用。
            例如，<code class="literal">CacheMarshaller200</code> 是 JBoss Cache 2.0.x. 的编码器，
            而 JBoss Cache 2.1.x 可能带有一个改进了报文协议的
            <code class="literal">CacheMarshaller210</code>。
            使用
            <code class="literal">VersionAwareMarshaller</code> 能帮助实现小版本之间的报文协议兼容性，
            但还是为我们提供了在较小或微小版本之间，调整和改进报文协议的弹性。
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2002"/>6.5.2.1. CacheLoaders</h4></div></div></div><p>
               一些已经存在的缓存加载器，例如
               <code class="literal">JDBCCacheLoader</code>
               和
               <code class="literal">FileCacheLoader</code> 也依赖使用
               <code class="literal">ObjectOutputStream</code> 的持久数据，
               但是现在，持久化到缓存存储时他们使用
               <code class="literal">VersionAwareMarshaller</code> 来编码持久数据。
            </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2019"/>6.5.3. CacheMarshaller200</h3></div></div></div><p>
            这个编码器将需要编码的常见对象当作不需要完整类型定义的类型，
            这些常见对象包括 <code class="literal">MethodCall</code>,
            <code class="literal">Fqn</code>,<code class="literal">DataVersion</code>
            , 甚至还包括一些 JDK 对象，如<code class="literal">String</code>,
            <code class="literal">List</code>,<code class="literal">Boolean</code>
            和其他类型。取而代之，编码器用<code class="literal">短的</code>表达来表述这些常见对象，
            这种方法更有效。
         </p><p>
            另外，通过计算引用数量来减少将某一对象重复写数次，这样有助于将流保持得很小、很高效。
         </p><p>
            同时，如果打开 <code class="literal">UseRegionBasedMarshalling</code> 选项（缺省是关闭的），
            编码器在写任何数据前在流中添加区域信息。
            这个区域信息是用 <code class="literal">Fqn</code> 的 <code class="literal">String</code> 表达格式。
            当解读时，可以用 <code class="literal">RegionManager</code>
            来查找相关的 <code class="literal">Region</code>，并用一个特定区域的
            <code class="literal">ClassLoader</code> 来解读流。
            当用于应用服务器集群状态时特别有用，
            因为每个服务器部署有它自己的 <code class="literal">ClassLoader</code>。
            查看下面有关
            <a href="#architecture.regions" title="6.6. 类加载和区域">区域</a>的章节，了解更多信息。
         </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="architecture.regions"/>6.6. 类加载和区域</h2></div></div></div><p>
         当用于应用服务器集群状态时，
         应用服务器里部署的应用，趋向于将他们应用中的特定对象实例放入缓存
         （或者在一个<code class="literal">HttpSession</code>里面），这些缓存是需要复制的。
         通用的应用服务器做法是，给每个部署的应用分配一个单独的
         <code class="literal">ClassLoader</code> 实例，
         但是让应用服务器的 <code class="literal">ClassLoader</code> 引用 JBoss Cache 库。
      </p><p>
         为了能让我们成功地从类加载器中编码和解读对象，我们使用一个叫做区域的概念。
         一个区域是缓存的一部分，这个部分共享一个类加载器
         （区域也有其他的用途，参见
         <a href="#eviction_policies" title="第 9 章 驱逐策略">驱逐策略</a>）。
      </p><p>
         通过使用
         <code class="literal">Cache.getRegion(Fqn fqn, boolean createIfNotExists)</code> 方法建立区域，
         这个方法返回一个 <code class="literal">Region</code> 接口的实现。
         一旦获得区域引用，就可以设置或置空区域的类加载器，
         区域可以激活/解除。
         缺省情况下，区域是激活的，除非
         <code class="literal">InactiveOnStartup</code> 配置属性设置为
         <code class="literal">true</code>。
      </p></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="clustering"/>第 7 章 集群</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2111">7.1. 缓存复制模式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2116">7.1.1. 本地模式</a></span></dt><dt><span class="section"><a href="#d0e2121">7.1.2. 复制的缓存</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2304">7.2. 失效</a></span></dt><dt><span class="section"><a href="#d0e2313">7.3. 状态传递</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2321">7.3.1. 状态传递类型</a></span></dt><dt><span class="section"><a href="#d0e2326">7.3.2. 字节数组和基于流的状态传递</a></span></dt><dt><span class="section"><a href="#d0e2333">7.3.3. 全部和部分状态传递</a></span></dt><dt><span class="section"><a href="#d0e2401">7.3.4. 暂时（“内存”）和持久状态传递</a></span></dt><dt><span class="section"><a href="#d0e2458">7.3.5. 配置状态传递</a></span></dt></dl></dd></dl></div><p>这章将围绕 JBoss Cache 集群有关问题展开讨论。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2111"/>7.1. 缓存复制模式</h2></div></div></div><p>JBoss Cache 可以配置成本地（独立）或集群。
      如果在一个集群中，可以将缓存配置成复制修改，或无效修改。下面有详细的讨论。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2116"/>7.1.1. 本地模式</h3></div></div></div><p>本地缓存不参与集群，并且也不与集群中其他缓存通信。
         因此，它的元素不需要串行化，但是我们推荐使它们可串行化，
         这样能使用户在任意时间修改缓存模式。
         对 JGroups 库的依赖还是存在的，尽管不再启动 JGroups 通道。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2121"/>7.1.2. 复制的缓存</h3></div></div></div><p>复制的缓存将修改复制到集群中的一些或所有其他缓存实例。
         复制可能发生在每次修改之后（没有事务），或者发生在事务的结束（提交时间）。
         </p><p>复制可以是同步的或异步的。
         使用那种选项，要依赖于应用需求。
         同步复制将阻塞调用者（例如，对于 <code class="literal">put()</code>），
         直到修改已经被成功复制到集群的所有节点。
         异步复制在后台完成复制（<code class="literal">put()</code> 直接返回）。
         JBoss Cache 也提供一个复制队列，其中修改被周期性地复制（例如基于间隔时间），
         或当队列尺寸超过一定的元素数量，或者二种方案的组合。
         </p><p>异步复制更快一些（没有调用阻塞），
         因为同步复制需要从集群所有节点确认他们已经成功收到并应用了修改（往返时间）。
         但是，当同步复制成功返回时，调用者知道所有修改已经正确应用到所有缓存实例，
         异步复制却无法做到这点。对于异步复制，仅仅将错误写到日志中。
         即便是使用事务，事务可能成功，而在所有缓存实例中的复制可能失败。
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="replication.tx"/>7.1.2.1. 复制的缓存和事务</h4></div></div></div><p>当使用事务时，复制操作仅发生在事务的边界，例如事务提交。
            既然只广播单一修改而不是一系列独立的修改，这会减少复制的流量，
            相比不使用事务，这会大大提高效率。这方面的另一个影响是，
            如果事务回滚，就不会产生贯穿集群的广播。
            </p><p>视运行集群的异步模式或同步模式而定，JBoss Cache 会分别使用单一阶段或
               <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol">两阶段提交
               </a> 协议。
            </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2146"/>7.1.2.1.1. 单一阶段提交</h5></div></div></div><p>当你使用的缓存模式是 REPL_ASYNC 时，所有的修改复制在单一调用中完成，
               这将指示远程缓存将这些修改应用到它们本地内存状态并在本地提交。
               既然通信是异步的，远程错误/回滚不会反馈给事务的源头。
               </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2151"/>7.1.2.1.2. 两阶段提交</h5></div></div></div><p>当你使用的缓存模式是 REPL_SYNC，在提交你的事务时，
               JBoss Cache 会广播一个预备调用，这个调用会带有有关这个事务所有修改。
               然后，远程缓存获得他们内存状态的本地锁，并应用修改。
               一旦所有的远程缓存应答了这个预备调用，事务的源头广播一个提交。
               这将指示所有的远程缓存提交他们的数据。如果任意一个缓存没有成功应答预备阶段，
               源头广播一个回滚。
               </p><p>注意，虽然预备阶段是同步的，提交和回滚阶段是异步的。
               这是因为
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/products/jta/">Sun 的 JTA 规范
                  </a>
                  没有规定事务资源怎么处理这个事务阶段的失败，
                  而且其他参与事务的资源可能有其他不确定状态。
                  就这点来看，我们去掉了事务这个阶段的同步通信开销。
                  那就是说，他们可以通过使用 <code class="literal">SyncCommitPhase</code>
                  和 <code class="literal">SyncRollbackPhase</code> 配置属性来强制同步。
               </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="br"/>7.1.2.2. 伙伴复制</h4></div></div></div><p>伙伴复制允许你禁止向集群里所有实例复制你的数据，
            而是每个实例在集群里选择一个或多个“伙伴”，并且只向这些指定的伙伴复制。
            这极大地有助于可伸缩性，因为每次向集群添加另外一个实例不再影响内存和网络流量。
            </p><p>伙伴复制最常使用方式之一是，
            Servlet 容器用一个复制缓存来存储 HTTP Session 数据。
            伙伴复制良好工作并获得真正益处的必要条件之一是，
            使用 <span class="emphasis"><em>会话亲缘性（<a href="#session_affinity"><em class="glossterm">session affinity</em></a>）</em></span>，
            更通用的一个说法是 HTTP Session 复制对话中的
            <span class="emphasis"><em>粘性对话（sticky sessions）</em></span>。
            这个术语的意思是，当某些数据频繁访问时，最佳的方式是总是访问一个实例，
            而不是循环的方式，因为这将有助于缓存集群优化伙伴的选择，它在伙伴中存储数据，
            并最小化复制流量。
            </p><p>如果做不到这点，有可能证明伙伴复制是一个负担而不是益处。
            </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2185"/>7.1.2.2.1. 选择伙伴</h5></div></div></div><div class="figure"><a id="d0e2188"/><div class="figure-contents"><div class="mediaobject"><img src="BuddyReplication.png" alt="BuddyLocator"/></div></div><p class="title"><b>图 7.1. BuddyLocator</b></p></div><br class="figure-break"/><p>伙伴复制使用一个 <code class="literal">BuddyLocator</code> 实例，
               它包含用于在网络上选择伙伴的逻辑。
               当前，JBoss Cache 带有单一实现 <code class="literal">NextMemberBuddyLocator</code>，
               缺省的情况下，如果没有提供其他实现将使用这个。
               <code class="literal">NextMemberBuddyLocator</code> 在集群中选择下一个成员，
               就像名字所暗示的一样，保证事件在每个实例的伙伴间传递。
               </p><p><code class="literal">NextMemberBuddyLocator</code> 接受两个可选参数。
                  </p><div class="itemizedlist"><ul><li><code class="literal">numBuddies</code>
                        - 说明每个实例应该选择多少伙伴来备份它的数据，缺省是1。
                     </li><li><code class="literal">ignoreColocatedBuddies</code>
                        - 意味着每个实例将<span class="emphasis"><em>试着</em></span>在不同的物理主机上选择伙伴。
                        如果做不到这一点，它将回来在同一主机查找，
                        缺省是<code class="literal">true</code>。
                     </li></ul></div><p>
               </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2225"/>7.1.2.2.2. 伙伴池</h5></div></div></div><p>也叫做<span class="emphasis"><em>复制组</em></span>，
               一个伙伴池是一个可选的结构，其中集群里的每个实例可以配置一个伙伴池名字。
               可以将这个想象成一个“特殊俱乐部会员资格”，其中当选择伙伴时，
               支持伙伴池的<code class="literal">BuddyLocator</code>将试图选择拥有相同伙伴池名称的伙伴。
               这允许系统管理员一定程度的弹性，控制可选伙伴的范围。
               例如，系统管理员可以将两个独立物理机架上的两个独立物理服务器上的两个实例放到同一个伙伴池中。
               因此，不是选择同一机架上的不同主机上的实例，
               <code class="literal">BuddyLocator</code> 将选择不同机架上的同一伙伴池内的实例，
               这将增加一定程度的冗余。
               </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2239"/>7.1.2.2.3. 故障转移</h5></div></div></div><p>在一个实例崩溃的灾难事件中，假定客户连接到了缓存
               （直接或间接，经过一些其他服务，例如 HTTP session 复制），
               能够将请求重定向到集群中的其他任意缓存实例。
               这就是 Data Gravitation 概念的出处。
               </p><p>Data Gravitation 是一个概念，如果请求集群上的某个实例而这个实例又没有包含所要信息，
               它将对集群中的其他实例要求这些数据。换句话说，数据是迟转移的，
               <span class="emphasis"><em>仅仅</em></span>在其他节点要求时迁移。
               这个策略防止网络风暴效应，
               预防仅仅因一个（或一些）节点死掉而导致大量数据拥挤在健康节点间。
               </p><p>如果在一些节点的主要部分没有找到数据，
               它将（可选地）要求其他实例检查他们为其他缓存存储的备份数据。
               这意味着，即便包含你 Session 的缓存死掉，
               其他实例将仍能让集群查找这个数据的备份来访问这个数据。
               </p><p>一旦定位了，这个数据将传回访问的实例，添加到这个实例的数据树。
               然后，这个数据（可选地）从所有其他节点移除（并备份），以便于如果使用了会话亲缘性，
               现在将亲和这个新的缓存实例，这个实例刚刚已经<span class="emphasis"><em>拥有</em></span>这个数据。
               </p><p>Data Gravitation 实现为一个拦截器。
               下面（所有可选）配置属性是关于 Data Gravitation 的。
                  </p><div class="itemizedlist"><ul><li><code class="literal">dataGravitationRemoveOnFind</code>
                        - 强迫所有拥有数据或拥有数据备份的远程缓存移除数据，
                        因此使请求缓存成为新的数据拥有者。
                        当然，这个移除仅发生在新拥有者完成向伙伴复制数据之后。
                        如果设置为 <code class="literal">false</code>，将广播驱逐而不是移除，
                        因此任何存储在缓存加载器的状态还是保留下来了。
                        如果你有一个共享的缓存加载器配置，这会很有用。缺省是<code class="literal">true</code>。
                     </li><li><code class="literal">dataGravitationSearchBackupTrees</code>
                        - 要求远程实例在搜索主数据结构的同时搜索他们的备份。
                        缺省是 <code class="literal">true</code>。影响的结果是，
                        如果是 <code class="literal">true</code>，则除了数据拥有者外，备份节点也反应 Data Gravitation 的请求。
                     </li><li><code class="literal">autoDataGravitation</code>
                        - 如果每个缓存都错过，Data Gravitation 是否发生。
                        缺省是 <code class="literal">false</code>，防止不必要的网络调用。
                        大多数情况下，当可能需要移动数据时，
                        可以传递一个<code class="literal">Option</code>来为每次调用打开 Data Gravitation。
                        如果 <code class="literal">autoDataGravitation</code> 是 <code class="literal">true</code>，
                        这个 <code class="literal">Option</code> 不是必须的。
                     </li></ul></div><p>
               </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2299"/>7.1.2.2.4. 配置</h5></div></div></div><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;Buddy&nbsp;Replication&nbsp;config&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;BuddyReplicationConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Enables&nbsp;buddy&nbsp;replication.&nbsp;This&nbsp;is&nbsp;the&nbsp;ONLY&nbsp;mandatory&nbsp;configuration&nbsp;element&nbsp;here.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">buddyReplicationEnabled</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">buddyReplicationEnabled</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;These&nbsp;are&nbsp;the&nbsp;default&nbsp;values&nbsp;anyway&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">buddyLocatorClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.buddyreplication.NextMemberBuddyLocator</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">buddyLocatorClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;&nbsp;numBuddies&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;backup&nbsp;nodes&nbsp;each&nbsp;node&nbsp;maintains.&nbsp;ignoreColocatedBuddies&nbsp;means</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;each&nbsp;node&nbsp;will&nbsp;*try*&nbsp;to&nbsp;select&nbsp;a&nbsp;buddy&nbsp;on&nbsp;a&nbsp;different&nbsp;physical&nbsp;host.&nbsp;If&nbsp;not&nbsp;able&nbsp;to&nbsp;do&nbsp;so&nbsp;though,</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;will&nbsp;fall&nbsp;back&nbsp;to&nbsp;colocated&nbsp;nodes.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">buddyLocatorProperties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numBuddies&nbsp;=&nbsp;1</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ignoreColocatedBuddies&nbsp;=&nbsp;true</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">buddyLocatorProperties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;A&nbsp;way&nbsp;to&nbsp;specify&nbsp;a&nbsp;preferred&nbsp;replication&nbsp;group.&nbsp;If&nbsp;specified,&nbsp;we&nbsp;try&nbsp;and&nbsp;pick&nbsp;a&nbsp;buddy&nbsp;which&nbsp;shares</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;same&nbsp;pool&nbsp;name&nbsp;(falling&nbsp;back&nbsp;to&nbsp;other&nbsp;buddies&nbsp;if&nbsp;not&nbsp;available).&nbsp;This&nbsp;allows&nbsp;the&nbsp;sysdmin&nbsp;to</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hint&nbsp;at&nbsp;backup&nbsp;buddies&nbsp;are&nbsp;picked,&nbsp;so&nbsp;for&nbsp;example,&nbsp;nodes&nbsp;may&nbsp;be&nbsp;hinted&nbsp;topick&nbsp;buddies&nbsp;on&nbsp;a&nbsp;different</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;physical&nbsp;rack&nbsp;or&nbsp;power&nbsp;supply&nbsp;for&nbsp;added&nbsp;fault&nbsp;tolerance.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">buddyPoolName</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">myBuddyPoolReplicationGroup</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">buddyPoolName</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Communication&nbsp;timeout&nbsp;for&nbsp;inter-buddy&nbsp;group&nbsp;organisation&nbsp;messages&nbsp;(such&nbsp;as&nbsp;assigning&nbsp;to&nbsp;and</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removing&nbsp;from&nbsp;groups,&nbsp;defaults&nbsp;to&nbsp;1000.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">buddyCommunicationTimeout</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">2000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">buddyCommunicationTimeout</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Whether&nbsp;data&nbsp;is&nbsp;removed&nbsp;from&nbsp;old&nbsp;owners&nbsp;when&nbsp;gravitated&nbsp;to&nbsp;a&nbsp;new&nbsp;owner.&nbsp;Defaults&nbsp;to&nbsp;true.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataGravitationRemoveOnFind</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataGravitationRemoveOnFind</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Whether&nbsp;backup&nbsp;nodes&nbsp;can&nbsp;respond&nbsp;to&nbsp;data&nbsp;gravitation&nbsp;requests,&nbsp;or&nbsp;only&nbsp;the&nbsp;data&nbsp;owner&nbsp;is</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supposed&nbsp;to&nbsp;respond.&nbsp;&nbsp;Defaults&nbsp;to&nbsp;true.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataGravitationSearchBackupTrees</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataGravitationSearchBackupTrees</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Whether&nbsp;all&nbsp;cache&nbsp;misses&nbsp;result&nbsp;in&nbsp;a&nbsp;data&nbsp;gravitation&nbsp;request.&nbsp;Defaults&nbsp;to&nbsp;false,&nbsp;requiring</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callers&nbsp;to&nbsp;enable&nbsp;data&nbsp;gravitation&nbsp;on&nbsp;a&nbsp;per-invocation&nbsp;basis&nbsp;using&nbsp;the&nbsp;Options&nbsp;API.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">autoDataGravitation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">autoDataGravitation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
</pre></div></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2304"/>7.2. 失效</h2></div></div></div><p>如果缓存配置成失效而不是复制，每次缓存里的数据修改，
      集群里其他缓存收到信息，通知他们的数据现在陈旧了需要从内存中驱逐。
      当在共享缓存加载器（查看有关缓存加载器的章节）的环境下使用失效时，
      远程缓存将使用共享的缓存加载器来取回已经修改的数据。
      这么做的好处是双重的：网络流量是极小的，因为失效信息相比复制更新数据来说是非常小的；
      同时，集群中的其他缓存可用一种延迟模式查询修改过的数据，也就是在需要时才查询。
      </p><p>失效信息在每次修改后发送（无事务的情况下），或者在事务结束成功提交时发送。
      这通常更加高效，因为通过事务可以将失效信息优化成一个整体，而不是基于每次修改都发送失效信息。
      </p><p>失效也可以是同步或异步的，就同复制的情景一样。
      同步失效要阻塞直到所有集群里的缓存接到失效信息并驱逐陈旧数据为止；
      而异步失效则用一种“发送并忘记”的模式工作，其失效信息广播出去但不阻塞等待反馈。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2313"/>7.3. 状态传递</h2></div></div></div><p>
         <span class="emphasis"><em>状态传递</em></span>是指这样的过程，
         JBoss Cache 通过从其他缓存实例获得当前状态并将这个状态整合进它自己状态，
         来完成自我准备并开始提供服务的过程。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2321"/>7.3.1. 状态传递类型</h3></div></div></div><p>从状态传递的视角，状态传递区分成三种类型。
         首先，在特定状态传递实现的环境下，由于底层产品的不同，有两种截然不同的状态传递类型：
         字节数组和基于流的状态传递。其次，依据被传递的子树，状态传递可以是全部或部分状态传递。
         全部传递表示全部缓存树的传递，而部分状态传递表示某部分子树的传递。
         最后，基于缓存的特定用法，状态传递可以是“内存”和“持久”传递。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2326"/>7.3.2. 字节数组和基于流的状态传递</h3></div></div></div><p>在 2.0 以前的所有缓存版本中，基于字节数组的传递是缺省的、唯一的传递方法。
         基于字节数组的传递将整个传递状态加载成一个字节数组，并将它发送给状态接收成员。
         这种方法的主要限制是，当传递状态很大时候（例如 1GB），
         会导致 OutOfMemoryException 异常。基于流的状态传递为读状态一方提供一个 InputStream，
         为写的一方提供一个 OutputStream。
         抽象的 OutputStream 和 InputStream 使状态传递以字节块的形式完成，所以对内存的需求很小。
         例如，如果应用状态表达成一棵树，总的尺寸是 1GB，不用提供 1GB 的字节数组来基于流做状态传递，
         可以用 N 字节的块来传递状态，而用户可以自己配置 N 的大小。
         </p><p>字节数组和基于流的状态传递完全是 API 透明的、可互换的，
         并通过标准的缓存配置 XML 文件静态配置。
         参考有关 JGroups 文档，了解如何从一种传递方式变到另外一种。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2333"/>7.3.3. 全部和部分状态传递</h3></div></div></div><p>如果打开内存或持久状态传递，在不同时间段，依据如何使用缓存，
         发生全部或部分状态传递。“全”状态传递是指，有关整个树的状态传递，
         例如根节点及其下面的所有节点。“部分”状态传递是指，仅树的一部分发生传递，
         例如一个给定 <a href="#fqn"><em class="glossterm">Fqn</em></a> 的节点及其下面的所有节点。
         </p><p>如果打开内存或持久状态传递，状态传递发生在下面时间段：
         </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>初始状态传递。这发生在缓存最初启动
               （作为 <code class="literal">start()</code> 方法过程的一部分）。
               这是一个全状态传递。状态从运行最久的缓存实例取得
                  <sup>[<a id="d0e2350" href="#ftn.d0e2350">5</a>]</sup>。
              如果有任何接收或整合状态问题，缓存不会启动。
               </p><p>初始状态传递将发生，除非：</p><div class="orderedlist"><ol><li><p>缓存的 <code class="literal">InactiveOnStartup</code> 属性设置为
                        <code class="literal">true</code>。这个属性与基于区域编码联合使用。
                     </p></li><li><p>使用伙伴复制。查看下面有关伙伴复制条件下，状态传递的更详细内容。
                     </p></li></ol></div></li><li><p>部分状态传递在区域激活之后。当使用基于区域的编码时，
               应用需要在缓存内注册一个特定类加载器。
               这个类加载器在解码缓存某一特定区域（子树）状态时使用。
               </p><p>注册后，应用调用
                  <code class="literal">cache.getRegion(fqn, true).activate()</code>，
                  这将为初始化一个相关子树状态的部分状态传递。
                  这个请求首先向集群里最久的缓存实例发出。
                  但是，如果这个实例的应答中没有状态，它将轮询每个实例请求状态，
                  直到某个实例提供了状态或所有实例都已经查询过。
               </p><p>一般来说，当使用基于区域的编码时，缓存的
                  <code class="literal">InactiveOnStartup</code> 属性设置为
                  <code class="literal">true</code>。
                  因为没有能力反串行化传递的状态而失败，这将禁止初始状态传递。
               </p></li><li><p>伙伴复制。当使用伙伴复制时，初始状态传递将关闭。
               反过来说，当缓存实例参加集群时，它成为一个或多个其他实例的伙伴，
               而一个或多个其他实例成为它的伙伴。
               每次一个实例判断有一个新伙伴为它提供备份，它将当前状态推给这个新伙伴。
               这个将状态的“推”给新伙伴与其他形式的状态传递有少许不同，
               它是基于“推”的方法（例如，接收者要求和接收状态）。
               但是，准备的过程和整合状态是一样的。
               </p><p>基于伙伴分组信息，状态的“推”操作只有在
                  <code class="literal">InactiveOnStartup</code> 属性设置为
                  <code class="literal">false</code> 的情况下发生。
                  如果是 <code class="literal">true</code>，伙伴间状态传递仅发生在
                  应用激活分组不同成员的区域的时候。
               </p><p>区域激活调用之后的部分状态传递也与伙伴伙伴复制的情况有少许不同。
               不是向某一缓存实例要求部分状态，而是尝试所有实例直到某一实例应答，
               在伙伴复制的情况下，激活区域的实例从每个作为备份的实例请求部分状态。
               </p></li></ol></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2401"/>7.3.4. 暂时（“内存”）和持久状态传递</h3></div></div></div><p>获得和整合的状态可以包括两种基本类型：
         </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>“暂时”或“内存”状态。这由另一个缓存实例的实际内存状态组成，
               状态由缓存不同内存节点上的内容来提供，它们被串行化并传递；
               接收方反串行化数据，在它自己内存树上建立对应的节点，
               用传递过来的数据组装这些节点。
               </p><p>通过将缓存的
                  <code class="literal">FetchInMemoryState</code> 配置属性设置为
                  <code class="literal">true</code> 来打开“内存”状态传递。
               </p></li><li><p>“持久”状态。只有使用非共享缓存加载器的情况下才应用。
               存储在状态提供者缓存持久存储中的状态被反串行化，并传递；
               接收方将数据传递给自己缓存加载器，这个缓存加载器将数据持久化到接受方的持久存储中。
               </p><p>通过将缓存加载器的
                  <code class="literal">fetchPersistentState</code> 属性设定为
                  <code class="literal">true</code> 来打开“持久”状态传递。
                  如果多个缓存加载器配置成一个链，则只有一个能将这个属性设置为 true。
                  否则在启动的时候将得到异常。
               </p><p>共享一个缓存加载器的持久状态传递没有意义，
               因为是相同持久存储提供数据，所以仅仅接受数据就可以了。
               因此如果使用了共享的缓存加载器，即便是缓存加载器的
                  <code class="literal">fetchPersistentState</code> 属性设置为
                  <code class="literal">true</code>，缓存也不会允许持久状态传递。
               </p></li></ol></div><p>具体那种状态传递更合适，将有赖于缓存的用法。
         </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>如果使用的是一个写通（<a href="#write_through"><em class="glossterm">Write-through</em></a>）缓存加载器，
               持久状态完全代表缓存状态。数据可能从内存状态中被驱逐，
               但是它还是在持久存储中。在这种情况下，如果缓存加载器没有共享，
               用持久状态传递来保证新缓存有正确的状态。
               如果请求的是一个“热”缓存（当缓存开始提供服务时，所有相关数据都在内存中），
               内存状态也被可以传递。
               （注意：也可以用<code class="literal">CacheLoaderConfig</code> 配置参数里的
                  <code class="literal">&lt;cacheloader&gt;&lt;preload&gt;</code>
                  元素来提供“暖”或“热”缓存，而不需要一个内存状态传递。
                  这个方法从某种程度上减轻了缓存实例提供状态的负担，
                  但是这增加了接收方的持久存储负担。）
               </p></li><li><p>如果缓存加载器带有钝化，状态的完整表达只能通过合并内存（例如没有钝化的）
               和持久（例如已经钝化的）状态才能得到。
               因此，需要一个内存状态传递。如果缓存加载器没有共享，
               则需要一个持久状态传递。
               </p></li><li><p>如果没有使用缓存加载器，并且缓存是一个独立的单边写缓存
               （例如，那些用于缓存数据，同时也可以在持久存储里找到，举例来说，数据库），
               内存状态是否传递依赖于请求的是否是一个“热”缓存。
               </p></li></ol></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2458"/>7.3.5. 配置状态传递</h3></div></div></div><p>为了保证状态传递按希望的来进行，很重要的一点是为所有集群节点配置相同的持久和暂时状态。
         这是因为，当请求时，基于字节数组的传递仅依赖于请求者的配置，
         而基于流的传递依赖于请求方和发送方的配置，而且希望一致。
         </p></div></div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="footnotes"><br/><hr/><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e2350" href="#d0e2350">5</a>] </sup>在 JGroups 术语中，运行最久的缓存实例总是协调程序。</p></div></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="cache_loaders"/>第 8 章 缓存加载器</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2480">8.1. CacheLoader 接口和生命周期</a></span></dt><dt><span class="section"><a href="#d0e2576">8.2. 配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2684">8.2.1. 单独存储配置</a></span></dt></dl></dd><dt><span class="section"><a href="#cl.impls">8.3. 带有的实现</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2779">8.3.1. 基于文件系统的缓存加载器</a></span></dt><dt><span class="section"><a href="#d0e2844">8.3.2. 向其他缓存委托的缓存加载器</a></span></dt><dt><span class="section"><a href="#cl.jdbc">8.3.3. JDBCCacheLoader</a></span></dt><dt><span class="section"><a href="#cl.s3">8.3.4. S3CacheLoader</a></span></dt><dt><span class="section"><a href="#cl.tcp">8.3.5. TcpDelegatingCacheLoader</a></span></dt><dt><span class="section"><a href="#cl.transforming">8.3.6. 转换缓存加载器</a></span></dt></dl></dd><dt><span class="section"><a href="#cl.pass">8.4. 缓存钝化</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3270">8.4.1. 钝化打开和关闭下缓存加载器的行为</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3300">8.5. 策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3305">8.5.1. 带有存储的本地缓存</a></span></dt><dt><span class="section"><a href="#d0e3316">8.5.2. 所有缓存共享相同存储情况下的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3338">8.5.3. 只有一个缓存带有一个存储的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3362">8.5.4. 每个缓存有它自己存储的复制缓存</a></span></dt><dt><span class="section"><a href="#d0e3405">8.5.5. 分层的缓存</a></span></dt><dt><span class="section"><a href="#d0e3425">8.5.6. 多个缓存加载器</a></span></dt></dl></dd></dl></div><p>JBoss Cache 可以用一个 <code class="literal">CacheLoader</code>
   将内存缓存备份到后台数据存储中。如果为 JBoss Cache 配置一个缓存加载器，
   那么将提供下列功能：
      </p><div class="itemizedlist"><ul><li>每当访问一个缓存元素，而这个元素没有在缓存中（例如，由于驱逐或由于服务器重启），
         如果能在后台存储中找到，那么缓存加载器透明地将元素加载到缓存中。
         </li><li>每当修改、添加或移除一个元素，那么这些修改都将通过缓存加载器保存到后台存储中。
         如果使用了事务，所有事务之内创建的修改都要保持。在事务的结尾，
         虽然没有明确的提示，<code class="literal">CacheLoader</code> 将参与事务管理器运行的两阶段提交协议。
         </li></ul></div><p>
   </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2480"/>8.1. CacheLoader 接口和生命周期</h2></div></div></div><div class="figure"><a id="d0e2483"/><div class="figure-contents"><div class="mediaobject"><img src="CacheLoader.png" alt="CacheLoader 接口"/></div></div><p class="title"><b>图 8.1. CacheLoader 接口</b></p></div><br class="figure-break"/><p>JBoss Cache 与一个 <code class="literal">CacheLoader</code> 实现的交互是这样的：
      当 <code class="literal">CacheLoaderConfiguration</code> （参见下面）是非空的，
      每个配置的 <code class="literal">CacheLoader</code> 实例在缓存建立时创建，在缓存启动时启动。
      </p><p>
         当缓存启动时调用<code class="literal">CacheLoader.create()</code>
         和 <code class="literal">CacheLoader.start()</code>。
         对应的，当缓存停止时调用 <code class="literal">stop()</code>
         和 <code class="literal">destroy()</code>。
      </p><p>其次，调用 <code class="literal">setConfig()</code> 和 <code class="literal">setCache()</code>。
      后一个用于存储缓存的引用，前一个用于配置这个 <code class="literal">CacheLoader</code> 实例。
      例如，在这里数据库缓存加载器建立与数据库的连接。
      </p><p>当没有使用事务时，调用 <code class="literal">CacheLoader</code> 接口的一组方法：
         <code class="literal">get()</code>, <code class="literal">put()</code>, <code class="literal">remove()</code>
         和 <code class="literal">removeData()</code>。它们立即获得/设置/移除数值。
         这些方法在接口的 javadoc 注释里面描述。
      </p><p>然后，有三个方法用于事务中：<code class="literal">prepare()</code>,
      <code class="literal">commit()</code> 和 <code class="literal">rollback()</code>。
      当事务提交时调用 <code class="literal">prepare()</code> 方法。
      它用一个事务对象和一个修改列表作为参数。
      事务对象可以用于事务哈希映射的键，而值是修改列表。
      每个修改列表有一些 <code class="literal">Modification</code> 元素，
      每一个表达在给定事务下对缓存的所做修改。
      当 <code class="literal">prepare()</code> 成功返回时，
      缓存加载器<span class="emphasis"><em>必须</em></span>能够成功提交（或回滚）事务。
      </p><p>
         JBoss Cache 在正确的时间，小心调用缓存加载器的 prepare(), commit() 和 rollback()。
      </p><p><code class="literal">commit()</code> 方法告诉缓存加载器提交事务，
      而 <code class="literal">rollback()</code> 方法告诉缓存加载器丢弃与这个事务有关的修改。
      </p><p>查看这个接口的 javadocs，了解每个方法的详细解释和需要满足的约定实现。
      </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2576"/>8.2. 配置</h2></div></div></div><p>象下面所示，缓存加载器在 JBoss Cache 的 XML 文件里面配置。
      注意，你可以在一个链里定义多个缓存加载器。
      这么做的影响就是，缓存将按照它们配置的顺序查找所有的缓存加载器，
      直到它找到一个有效的、非空数据元素。
      当执行写操作的时候，所有缓存加载器都写入（除非某个缓存加载器的
      <code class="literal">ignoreModifications</code> 元素设置为 <code class="literal">true</code>）。
      查看下面的配置部分，了解详情。
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_plain">...</span><br />
<span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;Cache&nbsp;loader&nbsp;config&nbsp;block&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheLoaderConfiguration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;if&nbsp;passivation&nbsp;is&nbsp;true,&nbsp;only&nbsp;the&nbsp;first&nbsp;cache&nbsp;loader&nbsp;is&nbsp;used;&nbsp;the&nbsp;rest&nbsp;are&nbsp;ignored&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">passivation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">passivation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;comma&nbsp;delimited&nbsp;FQNs&nbsp;to&nbsp;preload&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">preload</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">/</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">preload</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;are&nbsp;the&nbsp;cache&nbsp;loaders&nbsp;shared&nbsp;in&nbsp;a&nbsp;cluster?&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">shared</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">shared</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;we&nbsp;can&nbsp;now&nbsp;have&nbsp;multiple&nbsp;cache&nbsp;loaders,&nbsp;which&nbsp;get&nbsp;chained&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;the&nbsp;'cacheloader'&nbsp;element&nbsp;may&nbsp;be&nbsp;repeated&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.loader.JDBCCacheLoader</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;properties&nbsp;to&nbsp;pass&nbsp;in&nbsp;to&nbsp;the&nbsp;cache&nbsp;loader&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.driver=com.mysql.jdbc.Driver</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.url=jdbc:mysql://localhost:3306/jbossdb</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.user=root</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.password=</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.sql-concat=concat(1,2)</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;whether&nbsp;the&nbsp;cache&nbsp;loader&nbsp;writes&nbsp;are&nbsp;asynchronous&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">async</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">async</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;only&nbsp;one&nbsp;cache&nbsp;loader&nbsp;in&nbsp;the&nbsp;chain&nbsp;may&nbsp;set&nbsp;fetchPersistentState&nbsp;to&nbsp;true.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An&nbsp;exception&nbsp;is&nbsp;thrown&nbsp;if&nbsp;more&nbsp;than&nbsp;one&nbsp;cache&nbsp;loader&nbsp;sets&nbsp;this&nbsp;to&nbsp;true.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetchPersistentState</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetchPersistentState</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;determines&nbsp;whether&nbsp;this&nbsp;cache&nbsp;loader&nbsp;ignores&nbsp;writes&nbsp;-&nbsp;defaults&nbsp;to&nbsp;false.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">ignoreModifications</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">ignoreModifications</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;if&nbsp;set&nbsp;to&nbsp;true,&nbsp;purges&nbsp;the&nbsp;contents&nbsp;of&nbsp;this&nbsp;cache&nbsp;loader&nbsp;when&nbsp;the&nbsp;cache&nbsp;starts&nbsp;up.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defaults&nbsp;to&nbsp;false.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">purgeOnStartup</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">purgeOnStartup</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;defines&nbsp;the&nbsp;cache&nbsp;loader&nbsp;as&nbsp;a&nbsp;singleton&nbsp;store&nbsp;where&nbsp;only&nbsp;the&nbsp;coordinator&nbsp;of&nbsp;the</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cluster&nbsp;will&nbsp;store&nbsp;modifications.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">singletonStore</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;if&nbsp;true,&nbsp;singleton&nbsp;store&nbsp;functionality&nbsp;is&nbsp;enabled,&nbsp;defaults&nbsp;to&nbsp;false&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">enabled</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">enabled</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;implementation&nbsp;class&nbsp;for&nbsp;singleton&nbsp;store&nbsp;functionality&nbsp;which&nbsp;must&nbsp;extend</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.jboss.cache.loader.AbstractDelegatingCacheLoader.&nbsp;Default&nbsp;implementation</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;org.jboss.cache.loader.SingletonStoreCacheLoader&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.loader.SingletonStoreCacheLoader</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;properties&nbsp;and&nbsp;default&nbsp;values&nbsp;for&nbsp;the&nbsp;default&nbsp;singleton&nbsp;store&nbsp;functionality</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implementation&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushStateWhenCoordinator=true</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushStateWhenCoordinatorTimeout=20000</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">singletonStore</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p><code class="literal">class</code> 元素定义缓存加载器的实现类。
      （注意，由于 JBoss AS 属性编辑器里的一个错误，
      Windows 文件变量里的反斜线符号有可能不能正确展开，因此 replace="false" 可能是需要的）。
      注意，缓存加载器的实现必须有一个空的构造器。
      </p><p><code class="literal">properties</code> 元素定义给定实现的特定配置。
      例如，基于文件系统的实现，定义使用的根路径；
      而数据库实现可能定义数据库 URL，用户名和密码来建立数据库连接。
      这个配置通过 <code class="literal">CacheLoader.setConfig(Properties)</code> 传递给缓存加载器实现。
      注意，退格可能必须转义。
      </p><p><code class="literal">preload</code> 允许我们定义在缓存启动时可访问的节点列表或者甚至整个子树，
      这是为了预先加载这些节点关联的数据。
      缺省（“/”）的情况下，从后台存储加载全部可用数据到缓存，
      这可能不是一个好的做法，因为后台数据可能会很大。
      举个例子，<code class="literal">/a, /product/catalogue</code> 加载
      <code class="literal">/a</code> 和 <code class="literal">/product/catalogue</code> 子树到缓存，别的不加载。
      其他数据只有在被访问时才加载。当用户预期要频繁使用给定子树下的元素时，预先加载才有意义。
      </p><p>当加入一个集群时，<code class="literal">fetchPersistentState</code> 决定是否取回缓存的持久状态。
      只有一个配置的缓存加载器能够将这个属性设置为 true，如果多于一个缓存加载器这样设置，
      当启动缓存服务时会抛出配置异常。
      </p><p><code class="literal">async</code> 决定是否在写入缓存加载器时阻塞直到完成，
      或者在一个单独的线程里运行让写操作立即返回。
      如果设置为 true，就用使用的实际缓存加载器实例来构造一个
      <code class="literal">org.jboss.cache.loader.AsyncCacheLoader</code> 实例。
      然后，如果需要<code class="literal">AsyncCacheLoader</code> 使用一个单独的线程向底层缓存加载器委派所有的请求。
      查看 <code class="literal">AsyncCacheLoader</code> 的有关 javadoc，了解详细情况。
      如果没有说明， <code class="literal">async</code> 元素的缺省值是 <code class="literal">false</code>。
      </p><p>
         <span class="bold"><strong>注意有关 <code class="literal">async</code> 元素的使用：
         </strong></span>
         既然写操作是异步的，所以总有脏读的可能性，（即便是）当写操作成功时，也不能保证。
         当将 <code class="literal">async</code> 元素设置为 true，要时刻记住这一点。
      </p><p>
         <code class="literal">ignoreModifications</code> 决定写方法是否向下推送到某个缓存加载器。
         在同一个服务器上，作为内存缓存有些情况下，暂时应用数据应该只存在于基于文件的缓存加载器里，
         例如，网络里所有的服务器都使用一个远程共享的 <code class="literal">JDBCCacheLoader</code>。
         这个功能允许你写入“本地”文件缓存加载器里，而不是共享的 <code class="literal">JDBCCacheLoader</code>。
         这个属性缺省的情况下是 <code class="literal">false</code>，因此写操作传播到所有配置的缓存加载器。
      </p><p>
         当缓存加载器启动时，<code class="literal">purgeOnStatup</code> 腾空指定缓存加载器
         （如果 <code class="literal">ignoreModifications</code> 是 <code class="literal">false</code>）。
      </p><p>
         <code class="literal">shared</code> 指示缓存加载器是在不同缓存实例间共享的，
         例如，在一个集群里所有的实例使用相同 JDBC 设置与相同的远程的、共享的数据库对话。
         将这个属性设置为 <code class="literal">true</code>，将防止相同的数据被不同缓存实例反复和不必要地写入缓存加载器。
         缺省值是 <code class="literal">false</code>。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2684"/>8.2.1. 单独存储配置</h3></div></div></div><p>
            <code class="literal">singletonStore</code> 元素使修改只由集群里的一个节点保存，
            即协调程序。从根本上来说，无论何时任何数据进入某些节点，
            它总是复制以保持缓存内存状态的同步性，但是，协同程序有单独的责任将状态推到磁盘上。
            通过将所有节点的 <code class="literal">enabled</code> 子元素设定为 true，来激活这个功能。
            但是，还是这样，仅集群的协调程序在
            <code class="literal">cacheloader</code> 元素定义的底层缓存加载器存储修改。
            你不能将一个缓存加载器定义为 <code class="literal">shared</code>，
            而同时打开 <code class="literal">singletonStore</code>。
            <code class="literal">enabled</code> 的缺省值是 <code class="literal">false</code>。
         </p><p>
            可选择地，在 <code class="literal">singletonStore</code> 元素内，
            你可以定义一个 <code class="literal">class</code> 元素，说明提供单独存储功能的实现类。
            这个类必须扩展 <code class="literal">org.jboss.cache.loader.AbstractDelegatingCacheLoader</code>，
            如果缺失，它缺省是 <code class="literal">org.jboss.cache.loader.SingletonStoreCacheLoader</code>。
         </p><p>
            <code class="literal">properties</code> 子元素定义一些属性，
            这些属性允许修改提供单独存储功能类的行为。缺省情况下，
            <code class="literal">pushStateWhenCoordinator</code> 和
            <code class="literal">pushStateWhenCoordinatorTimeout</code> 属性已经定义，
            但是用户定义的提供单独存储功能类需要时，也应该添加更多属性。
         </p><p>当集群的拓扑结构变化时，由于重新选择协调程序的原因，某个节点变成了协调程序，
         这时 <code class="literal">pushStateWhenCoordinator</code> 允许将内存状态推送到缓存存储里。
         这在协调程序崩溃，而选择新协调程序又有时间间隙的情况下，非常有用。
         在这段时间内，如果这个属性设置为 <code class="literal">false</code>，并且缓存更新了，
         这些修改永远不会存储。这个属性设置为 <code class="literal">true</code>，
         将保证在这个过程中任意修改也能保存到缓存加载器里。
         如果每个节点的缓存加载器配置在不同的位置上，你也可能想将这个属性设置 <code class="literal">true</code>。
         缺省值是 <code class="literal">true</code>。
         </p><p>只有 <code class="literal">pushStateWhenCoordinator</code> 是 <code class="literal">true</code> 的情况下，
         <code class="literal">pushStateWhenCoordinatorTimeout</code> 才有意义。
         在这种情况下，它设定推送内存状态到底层缓存加载器过程所用时间的最大毫秒数，
         如果超过，在报告一个 <code class="literal">PushStateException</code> 异常。
         缺省值是 20000。
         </p><p>
            <span class="bold"><strong>有关使用 <code class="literal">singletonStore</code>元素的注意事项：
            </strong></span>
            将一个缓存加载器设定为独立的，并使用缓存钝化（通过驱逐），可能导致意想不到的效果。
            如果一个节点由于驱逐的原因导致钝化，而集群又处于选择新协调程序过程中，数据将丢失。
            这是因为，在哪个时间里，没有协调程序是激活的，因此，集群里没有节点存储钝化的节点。
            当协调程序离开集群，或者协调程序崩溃或停止反应，将在集群里选择一个新的协调程序。
         </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="cl.impls"/>8.3. 带有的实现</h2></div></div></div><p>当前，JBoss Cache 带有的实现如下。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2779"/>8.3.1. 基于文件系统的缓存加载器</h3></div></div></div><p>
            JBoss Cache 带有几个缓存加载器，它们利用文件系统作为数据存储。
            它们都需要 <code class="literal">&lt;cacheloader&gt;&lt;properties&gt;</code>
            配置元素包含一个 <code class="literal">location</code> 属性，这个属性映射到一个目录用做持久存储。
            （例如，<code class="literal">location=/tmp/myDataStore</code>）。
            这些加载器主要用于测试，不推荐在产品中使用。
         </p><div class="itemizedlist"><ul><li><p>
                  <code class="literal">FileCacheLoader</code> 是一个简单的基于文件的实现。
                  缺省情况下，这个缓存加载器在路径或树节点名称里检查任何可移植的字符问题，
                  例如，无效的字符，并产生警告信息。
                  通过向 <code class="literal">&lt;properties&gt;</code>
                  添加 <code class="literal">check.character.portability</code> 属性并设置为
                  <code class="literal">false</code> 可以关闭这些检查。
                  （例如，<code class="literal">check.character.portability=false</code>）。
               </p><p>
                  FileCacheLoader 有几个局限，限制了它在产品环境中的使用。
                  或者，如果在这种环境下使用，应该小心使用，并对这些局限有充足的理解。
                  </p><div class="itemizedlist"><ul><li>由于 FileCacheLoader 在磁盘（目录和文件）上表达树结构的方式，
                     对于很深的树遍历的效率很低。
                     </li><li>应该避免在共享的文件系统下使用，例如，Windows 共享 NFS。
                     因为这不能实现正确的文件加锁，可能导致数据毁坏。
                     </li><li>如果使用 NONE 的隔离等级，可能会因为多个线程试图写相同文件而造成写操作失败。
                     </li><li>文件系统本身不支持事务，因此试图在事务环境下使用缓存，
                     失败后对文件的写操作（在提交阶段发生）不能恢复。
                     </li></ul></div><p>
                    作为经验，推荐不要将 FileCacheLoader 用在高并发、事务管理和压力大的环境下，
                     它的作用仅限于测试。
               </p></li><li><p>
                  <code class="literal">BdbjeCacheLoader</code> 是一个基于 Oracle/Sleepycat 的
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.oracle.com/database/berkeley-db/index.html">BerkeleyDB Java Edition</a>
                  的缓存加载器实现。
               </p></li><li><p>
                  <code class="literal">JdbmCacheLoader</code> 是一个基于
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jdbm.sourceforge.net/">JDBM engine</a> 的缓存加载器实现，
                  是一个很快，而且自由的 BerkeleyDB 替代品。
               </p></li></ul></div><p>注意，BerkeleyDB 实现要比基于文件系统的实现更加高效，并且提供事务保证，
         但是如果随着应用一起发布需要一个商业许可
         （查看 http://www.oracle.com/database/berkeley-db/index.html 了解更多详情）。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2844"/>8.3.2. 向其他缓存委托的缓存加载器</h3></div></div></div><div class="itemizedlist"><ul><li><p>
                  <code class="literal">LocalDelegatingCacheLoader</code>，
                  它能从另一个本地（同一个 JVM）缓存加载和存储。
               </p></li><li><p>
                  <code class="literal">ClusteredCacheLoader</code>，它允许查询相同集群里其他缓存的内存数据，
                  使用相同集群协议复制数据。然而<span class="emphasis"><em>不</em></span>存储写，同样地，复制仅针对需要的更新。
                  你需要说明一个叫 <code class="literal">timeout</code> 属性，它是一个长整形，
                  说明在假定一个空值前，缓存加载器等待集群反应的毫秒数。
                  例如， <code class="literal">timeout = 3000</code> 将使用一个 3 秒的超时值。
               </p></li></ul></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="cl.jdbc"/>8.3.3. JDBCCacheLoader</h3></div></div></div><p>JBossCache 带有一个基于 JDBC 的缓存加载器实现，它向一个关系型数据库存储/加载节点状态。
         实现类是 <code class="literal">org.jboss.cache.loader.JDBCCacheLoader</code>。
         </p><p>当前实现仅使用一个表。表里的每行代表一个节点，包含三个列：
            </p><div class="itemizedlist"><ul><li><code class="literal">Fqn</code> 列（也是主键列）
               </li><li>节点内容列（属性/值对）
               </li><li>父 <code class="literal">Fqn</code> 列
               </li></ul></div><p>
         </p><p>
            <code class="literal">Fqn</code> 存储成字符串。节点内容存储成一个 <a href="#blob"><em class="glossterm">BLOB</em></a>。
            <span class="emphasis"><em>警告：</em></span>JBoss Cache 没有约束 <code class="literal">Fqn</code> 里使用的对象类型，
            但是这个缓存加载器实现需要 <code class="literal">Fqn</code> 仅包含
            <code class="literal">java.lang.String</code> 类型的对象。
            另一个 <code class="literal">Fqn</code> 的约束是它的长度。
            既然 <code class="literal">Fqn</code> 是一个主键，它的缺省列类型是 <code class="literal">VARCHAR</code>，
            由使用的数据库来决定存储文本值的最大长度。
         </p><p>查看
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JDBCCacheLoader">
               http://wiki.jboss.org/wiki/Wiki.jsp?page=JDBCCacheLoader
            </a> 来了解特定数据库系统的配置提示。
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2926"/>8.3.3.1. JDBCCacheLoader 配置</h4></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2929"/>8.3.3.1.1. 表配置</h5></div></div></div><p>通过下列属性配置表和列名字，以及列类型。
                  </p><div class="itemizedlist"><ul><li><span class="emphasis"><em>cache.jdbc.table.name</em></span>
                        - 表名字。可以在给定表的前面追加模式名：
                        &lt;schema_name&gt;.&lt;table_name&gt;。
                        缺省值是“jbosscache”。
                     </li><li><span class="emphasis"><em>cache.jdbc.table.primarykey</em></span>
                        - 表的主键名。缺省值是“jbosscache_pk”。
                     </li><li><span class="emphasis"><em>cache.jdbc.table.create</em></span>
                        - 可以是 true 或 false。指示在启动时，是否创建表。
                        如果是 true，如果表还不存在就创建它。缺省值是 true。
                     </li><li><span class="emphasis"><em>cache.jdbc.table.drop</em></span>
                        - 可以是 true 或 false。指示在关闭时，是否删除表。缺省值是 true。
                     </li><li><span class="emphasis"><em>cache.jdbc.fqn.column</em></span>
                        - FQN 列名。缺省值是“fqn”。
                     </li><li><span class="emphasis"><em>cache.jdbc.fqn.type</em></span>
                        - FQN 列类型。缺省值是“varchar(255)”。
                     </li><li><span class="emphasis"><em>cache.jdbc.node.column</em></span>
                        - 节点内容列名。缺省值是“node”。
                     </li><li><span class="emphasis"><em>cache.jdbc.node.type</em></span>
                        - 节点内容列类型。缺省值是“blob”。
                        这个类型必须定义成所用数据库的正确二进制数据类型。
                     </li></ul></div><p>
               </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2968"/>8.3.3.1.2. DataSource（数据源）</h5></div></div></div><p>如果你在一个管理环境（例如一个应用服务器）中使用 JBossCache，
               你可以指定想要使用的 DataSource 的 <a href="#jndi"><em class="glossterm">JNDI</em></a> 名。
                  </p><div class="itemizedlist"><ul><li><span class="emphasis"><em>cache.jdbc.datasource</em></span>
                        - DataSource 的 JNDI 名。缺省是 <code class="literal">java:/DefaultDS</code>。
                     </li></ul></div><p>
               </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2985"/>8.3.3.1.3. JDBC 驱动</h5></div></div></div><p>如果你<span class="emphasis"><em>没有</em></span>使用 DataSource，
               你可以通过下列配置属性，使用 JDBC 驱动访问数据库。
                  </p><div class="itemizedlist"><ul><li><span class="emphasis"><em>cache.jdbc.driver</em></span>
                        - JDBC 驱动程序的全名。
                     </li><li><span class="emphasis"><em>cache.jdbc.url</em></span>
                        - 数据库连接 URL。
                     </li><li><span class="emphasis"><em>cache.jdbc.user</em></span>
                        - 数据库连接用户名。
                     </li><li><span class="emphasis"><em>cache.jdbc.password</em></span>
                        - 数据库连接密码。
                     </li></ul></div><p>
               </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e3011"/>8.3.3.1.4. c3p0 连接池</h5></div></div></div><p>当在应用服务器之外独立运行时，JBoss Cache 使用 c3p0:JDBC 数据源/资源池库，
               来实现 JDBC 连接池。为了打开这个功能，只需编辑下列属性：
                  </p><div class="itemizedlist"><ul><li><span class="emphasis"><em>cache.jdbc.connection.factory</em></span>
                        - 连接工厂类名。如果没有设置，缺省是标准的不支持池的实现。
                        要打开 c3p0 池，只要为 c3p0 设置连接工厂类。参看下面的例子。
                     </li></ul></div><p>
               </p><p>你也可以在相同的缓存加载器属性部分设置任意 c3p0 参数，
               但是不要忘记属性名要以“c3p0.”开头。想要查找可用的属性列表，
               请检查 c3p0 库中 c3p0 文档，发布在
               <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://sourceforge.net/projects/c3p0">c3p0:JDBC 数据源/资源池</a>。
               同时，为了提供快速、方便的尝试不同池参数的方法，所有这些属性都可以通过系统属性设置，
               这种方法可以覆盖 JBoss Cache XML 配置文件里的任意属性值，
               例如 <code class="literal">-Dc3p0.maxPoolSize=20</code>。
               如果在配置文件或系统属性里面都没有定义 c3p0 属性，将应用 c3p0 文档里指明的缺省值。
               </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h5 class="title"><a id="d0e3030"/>8.3.3.1.5. 配置例子</h5></div></div></div><p>下面是一个使用 Oracle 作为数据库的 JDBCCacheLoader 的例子。
               CacheLoaderConfiguration XML 元素包含一个任意的属性集，
               定义有关数据库的配置。
               </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheLoaderConfiguration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">passivation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">passivation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">preload</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">/some/stuff</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">preload</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.loader.JDBCCacheLoader</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.table.name=jbosscache</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.table.create=true</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.table.drop=true</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.table.primarykey=jbosscache_pk</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.fqn.column=fqn</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.fqn.type=varchar(255)</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.node.column=node</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.node.type=blob</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.parent.column=parent</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.driver=oracle.jdbc.OracleDriver</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.url=jdbc:oracle:thin:@localhost:1521:JBOSSDB</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.user=SCOTT</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.password=TIGER</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.sql-concat=concat(1,2)</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">async</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">async</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetchPersistentState</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetchPersistentState</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">ignoreModifications</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">ignoreModifications</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">purgeOnStartup</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">purgeOnStartup</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>另外一种配置整个 JDBC 连接的方法是，给出一个已经存在的数据源名：
               </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheLoaderConfiguration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">passivation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">passivation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">preload</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">/some/stuff</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">preload</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.loader.JDBCCacheLoader</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.datasource=java:/DefaultDS</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">async</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">async</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetchPersistentState</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetchPersistentState</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">ignoreModifications</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">ignoreModifications</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">purgeOnStartup</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">purgeOnStartup</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>使用 c3p0 JDBC 连接池的缓存加载器配置例子：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheLoaderConfiguration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">passivation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">passivation</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">preload</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">/some/stuff</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">preload</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.loader.JDBCCacheLoader</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.table.name=jbosscache</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.table.create=true</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.table.drop=true</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.table.primarykey=jbosscache_pk</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.fqn.column=fqn</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.fqn.type=varchar(255)</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.node.column=node</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.node.type=blob</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.parent.column=parent</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.driver=oracle.jdbc.OracleDriver</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.url=jdbc:oracle:thin:@localhost:1521:JBOSSDB</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.user=SCOTT</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.password=TIGER</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.sql-concat=concat(1,2)</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.jdbc.connection.factory=org.jboss.cache.loader.C3p0ConnectionFactory</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c3p0.maxPoolSize=20</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c3p0.checkoutTimeout=5000</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">async</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">async</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetchPersistentState</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetchPersistentState</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">ignoreModifications</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">ignoreModifications</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">purgeOnStartup</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">purgeOnStartup</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="cl.s3"/>8.3.4. S3CacheLoader</h3></div></div></div><p>
            <code class="literal">S3CacheLoader</code> 使用
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://aws.amazon.com/">Amazon S3</a>
            （Simple Storage Solution，简单存储解决方案）来存储缓存数据。
            既然 Amazon S3 是远程网络存储，并且具有相当高的延迟，
            因此它最适合存储大块数据的缓存，例如媒体或文件。
            但是如果你想远程管理，则可以认为这个缓存加载器比 JDBC 或基于文件系统的缓存要好，
            是个高可靠性的存储。
            或者，为运行在 Amazon 的 EC2 （Elastic Compute Cloud）上的应用程序使用它。            
         </p><p>
            如果你计划用 Amazon S3 来存储，并考虑与 JBoss Cache 一起使用，
            JBoss Cache 自己为你的数据提供一个内存缓存，以便最小化远程访问调用的数量，
            这样减少延迟和取回 Amazon S3 数据的代价。
            在缓存复制的情况下，你也可以从你的本地集群里加载数据而不用非得每次远程访问。
         </p><p>
            注意，Amazon S3 不支持事务。如果在你的应用程序里使用了事务，
            当使用这个缓存加载器时，有可能有状态不一致的可能性。
            但是，写是原子的，也就是说如果写失败了，就认为没有写任何东西，数据永远不会损坏。
         </p><p>
            数据以节点的 Fqn 作为键来存储，而节点数据用
            <code class="literal">CacheSPI.getMarshaller()</code> 实例串行化为 java.util.Map。
            查阅有关如何组织和存储数据的 javadoc。
            数据通过使用 Java 串行化来存储。
            应该认识到，这么做意味着，对非 JBoss Cache 客户端来说，通过 HTTP 不容易访问这些数据。
            为了改进这个缓存加载器这方面的功能，我们期望您的反馈和帮助。
         </p><p>
            用这个缓存加载器，单稽操作，例如
            <code class="literal">Node.remove(Object)</code> 和
            <code class="literal">Node.put(Object, Object)</code> 是最慢的，
            因为数据是存储在单一的 Map 实例。
            使用批量操作，例如
            <code class="literal">Node.replaceAll(Map)</code> 和
            <code class="literal">Node.clearData()</code> 更有效一些。
            也可以尝试 <code class="literal">cache.s3.optimize</code> 选项。
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3082"/>8.3.4.1. Amazon S3 库</h4></div></div></div><p>在缺省的发布程序中提供 S3 缓存加载器，但是需要一个运行时访问服务的库。
            这个运行时库可以通过 Sourceforge 的 Maven 库来包含。
            将下面的部分包含在你的 pom.xml 文件中：
            </p><pre class="programlisting">
      &lt;repository&gt;
         &lt;id&gt;e-xml.sourceforge.net&lt;/id&gt;
         &lt;url&gt;http://e-xml.sourceforge.net/maven2/repository&lt;/url&gt;
      &lt;/repository&gt;
        ...
      &lt;dependency&gt;
         &lt;groupId&gt;net.noderunner&lt;/groupId&gt;
         &lt;artifactId&gt;amazon-s3&lt;/artifactId&gt;
         &lt;version&gt;1.0.0.0&lt;/version&gt;
         &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;/dependency&gt;
              
            </pre>
            如果你不使用 Maven，你还可以通过浏览库或通过
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://e-xml.sourceforge.net/maven2/repository/net/noderunner/amazon-s3/1.0.0.0/amazon-s3-1.0.0.0.jar">这个 URL</a>.
            下载 amazon-s3 库。
         </div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3093"/>8.3.4.2. 配置</h4></div></div></div><p>最小程度，你必须配置你的 Amazon S3 访问键和秘密访问键。
            下面的配置键按照一般用途的顺序排列。
            </p><p>
               </p><div class="itemizedlist"><ul><li><code class="literal">cache.s3.accessKeyId</code>
                     - Amazon S3 访问键，从你的帐户档案中获得。
                  </li><li><code class="literal">cache.s3.secretAccessKey</code>
                     - Amazon S3 秘密访问键，从你的帐户档案中获得。
                     因为这是一个密码，所以小心不要发布出去或者在构建完成的软件中包含这个秘密键。
                  </li><li><code class="literal">cache.s3.secure</code>
                     - 缺省值是 <code class="literal">false</code>：通过公网时，数据流是没有加密发送的。
                     设为 <code class="literal">true</code>，使用 HTTPS。
                     注意，没有加密的上传和下载使用的 CPU 也少。
                  </li><li><code class="literal">cache.s3.bucket</code>
                     - 存储数据的存储桶的名称。对不同的缓存使用相同的访问键，应使用不同存储桶的名字。
                     阅读 S3 文档中有关存储桶的定义。缺省值是 <code class="literal">jboss-cache</code>。
                  </li><li><code class="literal">cache.s3.callingFormat</code>
                     - <code class="literal">PATH</code>, <code class="literal">SUBDOMAIN</code>, 或
                     <code class="literal">VANITY</code> 中的一个。
                     阅读 S3 文档有关调用域的用法。缺省值是 <code class="literal">SUBDOMAIN</code>。
                  </li><li><code class="literal">cache.s3.optimize</code>
                     - 缺省值是 <code class="literal">false</code>。如果是 true，
                     <code class="literal">put(Map)</code> 操作将替换存储在 Fqn 中的数据，
                     而不是尝试取回并合并。（目前，这个选项还处于试验的初期。）
                  </li><li><code class="literal">cache.s3.parentCache</code>
                     - 缺省值是 <code class="literal">true</code>。如果你使用多个共享相同 S3 存储桶的缓存，
                     将这个值设定为 <code class="literal">false</code>，那将移除其他缓存建立节点的父节点。
                     （这不是一个通常用法。）
                     <p>
                        JBoss Cache 在一个树型格式里存储节点，并自动创建中间必须的父节点。
                        S3 缓存加载器也必须创建这些父节点，这才能让类似
                        <code class="literal">getChildrenNames</code> 的操作正常工作。
                        为每个 <code class="literal">put</code> 操作检查所有父节点是否存在是相当费时的，
                        因此缺省情况下，缓存加载器缓存这些已经存在的父节点。
                     </p></li><li><code class="literal">cache.s3.location</code>
                     - 这个参数为你的数据选择一个主要的存储位置，以减少加载和取回的延迟。
                     设定为 <code class="literal">EU</code>，则在欧洲存储数据。
                     缺省值是 <code class="literal">null</code>，在美国存储数据。
                  </li></ul></div><p>
            </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="cl.tcp"/>8.3.5. TcpDelegatingCacheLoader</h3></div></div></div><p>这个缓存加载器允许向另一个 JBoss Cache 实例委派加载和存储，
         这另一个实例可能存在于：（a）相同的地址空间里；（b）相同的主机上不同的进程里；
         （c）不同的主机上不同的进程里。
         </p><p>TcpDelegatingCacheLoader 与一个远程
            <code class="literal">org.jboss.cache.loader.tcp.TcpCacheServer</code> 对话，
            这可能是命令行启动的一个独立进程，或 JBoss AS 里嵌入的 MBean。
            <code class="literal">TcpCacheServer</code> 有一个别的 JBoss Cache 实例的引用，
            这个引用可以是它自己创建的，或者给它的（例如通过 JBoss，使用依赖注入）。
         </p><p>
            在 JBoss Cache 2.1.0 版本中，如果与 TcpCacheServer 的连接丢失，
            TcpDelegatingCacheLoader 能够透明地处理重新连接。
         </p><p>TcpDelegatingCacheLoader 的配置中包括主机和远程 TcpCacheServer 端口，
         并使用这些与之通信。另外，用两个新的可选参数控制与 TcpCacheServer 的透明重连接。
         <code class="literal">timeout</code> 属性（缺省是 5000）定义 TcpCacheServer 放弃并抛出异常之前，
         缓存加载器必须连续尝试连接 TcpCacheServer 的时间长度。
         <code class="literal">reconnectWaitTime</code> （缺省值 500）是如果它检测到通信失败尝试重新连接之前，
         需要等待的时间间隔。后面的这两个参数可以用于增加缓存加载器容忍故障的水平，
         用于处理 TcpCacheServer 的重启。
         </p><p>配置如下所示：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheLoaderConfiguration&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.loader.TcpDelegatingCacheLoader</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;host=myRemoteServer</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port=7500</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout=10000</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reconnectWaitTime=250</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">cacheloader</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>这意味着，JBoss Cache 的这个实例将委派所有的加载和存储要求到远程 TcpCacheServer，
         这个 TcpCacheServer 在 <code class="literal">myRemoteServer:7500</code> 上运行。
         </p><p>典型的使用方法可能是，多个同一个集群中 JBoss Cache 复制实例都委派到相同的 TcpCacheServer 实例。
         TcpCacheServer 自己可能通过 JDBCCacheLoader 委派到一个数据库，
         但是注意的一点是，如果我们有 5 个节点都访问相同的数据集，他们将从 TcpCacheServer 加载数据，
         这会在每次卸载数据集时执行一个 SQL 声明。
         如果节点直接连接数据库，那么我们多次执行相同的 SQL。
         因此将 TcpCacheServer 作为 DB 前的自然缓存
         （假定一个网络往返比 DB 访问快，而 DB 访问通常也包括一个网络往返）。
         </p><p>为了减轻单点失败，我们可以配置多个缓存加载器。
         第一个缓存加载器是一个 ClusteredCacheLoader，第二个是一个 TcpDelegatingCacheLoader，
         最后一个是一个 JDBCacheLoader，用一个渐增的顺序有效地向缓存定义我们的访问代价。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="cl.transforming"/>8.3.6. 转换缓存加载器</h3></div></div></div><p>在 JBoss Cache 2.0 里，数据写入基于 <code class="literal">FileCacheLoader</code> 和
            <code class="literal">JDBCCacheLoader</code> 的缓存加载器的方式发生了变化，
            现在这些缓存加载器使用相同的编码框架写或读数据，这个编码框架也用于跨越网络复制数据。
            这些变化对复制的效果影响不大，因为它仅需要其余的节点理解这个格式。
            但是，修改缓存存储里数据的格式带来一个新的问题：已经将他们的数据存储在 JBoss Cache 1.x.x 格式的用户
            如何迁移他们的存储到 JBoss Cache 2.0 格式？
         </p><p>请记住这一点，JBoss Cache 2.0 带有两个缓存加载器实现，叫做
            <code class="literal">org.jboss.cache.loader.TransformingFileCacheLoader</code> 和
            <code class="literal">org.jboss.cache.loader.TransformingJDBCCacheLoader</code>，
            位于可选的 jbosscache-cacheloader-migration.jar 文件里。
            他们是一次性地缓存加载器，将数据从 JBoss Cache 1.x.x 格式的缓存存储中读取出来，
            并写入 JBoss Cache 2.0 格式的缓存存储。
         </p><p>对于用户来说，做法就是即刻修改他们已经存在的（多个）缓存配置文件以使用这些缓存加载器，
         并用这些缓存加载器建立一个小的 Java 应用，这个 Java 应用创建这个缓存的一个实例递归读取整个缓存，
         并将数据写回缓存。一旦数据已经转换，用户可以返回到他们原先的（多个）缓存配置文件。
         为了帮助用户完成这个任务，已经构建了一个缓存加载器迁移的例子，这个例子位于 JBoss Cache 发布程序的
            <code class="literal">examples/cacheloader-migration</code> 目录下。
            这个例子叫做 <code class="literal">examples.TransformStore</code>，
            它独立于存储在缓存里的实际数据，因为不管是什么它都递归地读出并写回。
            极力推荐想要移植他们数据的人，先运行这个例子。
            这个例子有一个 <code class="literal">readme.txt</code> 文件，详细描述例子自身信息，
            也可将它用作自己应用程序的基础。
         </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="cl.pass"/>8.4. 缓存钝化</h2></div></div></div><p>当一个缓存驱逐数据时，可以用缓存加载器强制节点的钝化和激活。
      </p><p>
         <span class="emphasis"><em>缓存钝化</em></span>是当驱逐时，从内存缓存移除一个对象并将它写入二级数据存储
         （例如，文件系统、数据库）的过程。
         <span class="emphasis"><em>缓存激活</em></span>是当需要使用时，将一个对象从数据存储中恢复到内存缓存的过程。
         在这两种情况下，用配置的缓存加载器读出和写入数据存储。
      </p><p>当一个驱逐策略起作用，从缓存中驱逐一个节点时，如果打开钝化，
      则一个有关节点正在被钝化的通知发送给缓存监听器，然后节点及其子节点将被存储在缓存加载器存储中。
      当用户试图取回一个先前被驱逐的节点时，从缓存加载器存储里加载（延迟模式）节点。
      当节点及其子节点加载后，它们就从缓存加载器中移除，一个通知发送给缓存监听器说明这个节点已经激活。
      </p><p>为了打开缓存的钝化/激活功能，你可以将 <code class="literal">passivation</code> 设置为 true。
      缺省值是 <code class="literal">false</code>。当使用钝化时，只使用配置的第一个缓存加载器，其他的都忽略。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3270"/>8.4.1. 钝化打开和关闭下缓存加载器的行为</h3></div></div></div><p>
            当关闭钝化时，每当修改、添加或移除一个元素，则这个修改就会通过缓存加载器持久化到后台存储。
            在驱逐和缓存加载器之间没有直接的关系。如果你不使用驱逐，持久存储内容基本上是内存里内容的一个拷贝。
            如果你使用驱逐，持久存储内容基本上是内存里内容的一个超集
            （例如，它包括已经从内存中驱逐的节点）。
         </p><p>
            当打开钝化时，驱逐和缓存加载器之间有一个直接的关系。
            通过缓存加载器写入持久存储仅发生在驱逐过程的一部分。
            当应用程序将数据读回内存时，数据从持久存储删除。
            内存里内容和持久存储内容是整个信息集合的两个子集，而且两个子集没有交叉。
         </p><p>
            下面是一个简单的例子，显示一个 6 步过程每步过程后的 RAM 里状态和持久存储里状态：
         </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li>Insert /A</li><li>Insert /B</li><li>Eviction thread runs, evicts /A</li><li>Read /A</li><li>Eviction thread runs, evicts /B</li><li>Remove /B</li></ol></div><p>当关闭钝化时：</p><pre class="programlisting">
            1) RAM: /A Disk: /A
            2) RAM: /A, /B Disk: /A, /B
            3) RAM: /B Disk: /A, /B
            4) RAM: /A, /B Disk: /A, /B
            5) RAM: /A Disk: /A, /B
            6) RAM: /A Disk: /A
         </pre><p>当打开钝化时：</p><pre class="programlisting">
            1) RAM: /A Disk:
            2) RAM: /A, /B Disk:
            3) RAM: /B Disk: /A
            4) RAM: /A, /B Disk:
            5) RAM: /A Disk: /B
            6) RAM: /A Disk:
         </pre></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3300"/>8.5. 策略</h2></div></div></div><p>
         这个部分讨论不同缓存加载器类型和配置选项的组合类型下，实现的特定结果。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3305"/>8.5.1. 带有存储的本地缓存</h3></div></div></div><p>这是最简单的情况。我们有一个缓存模式是 <code class="literal">LOCAL</code> 的 JBoss Cache 实例，
         因此没有进行复制。缓存加载器简单地从存储中加载不存在的元素，并将修改存回存储。
         当缓存启动时，依赖 <code class="literal">preload</code> 元素，一部分数据可以预先加载，
         因此缓存部分热身。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3316"/>8.5.2. 所有缓存共享相同存储情况下的复制缓存</h3></div></div></div><p>下面的图显示 2 个 JBoss Cache 实例共享相同的后台存储：
         </p><div class="figure"><a id="d0e3321"/><div class="figure-contents"><div class="mediaobject"><img src="SharedCacheLoader.png" alt="2 个节点共享一个后台存储"/></div></div><p class="title"><b>图 8.2. 2 个节点共享一个后台存储</b></p></div><br class="figure-break"/><p>两个节点都有一个缓存加载器，这些缓存加载器访问一个公用的共享后台存储。
         例如，这可以是一个共享文件系统（使用 FileCacheLoader），或一个共享的数据库。
         因为两个节点访问相同的存储，在启动时他们不必需要状态转移。
            <sup>[<a id="d0e3329" href="#ftn.d0e3329">6</a>]</sup>
            相反地，<code class="literal">FetchInMemoryState</code> 属性可以设置为 false，
            结果会得到一个“冷”缓存，随着第一时间的元素访问他们会逐渐热起来。
            这将意味着，在某一时间集群里个别的缓存可以有不同的内存状态
            （主要依赖于他们的预加载和驱逐策略）。
         </p><p>当存储一个值，写程序在后台存储里小心地存储修改。例如，如果 node1 修改 C1 并且 node2 修改 C2，
         那么 node1 将让它的缓存加载器存储 C1，并且 node2 将让它的缓存加载器来存储 C2。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3338"/>8.5.3. 只有一个缓存带有一个存储的复制缓存</h3></div></div></div><div class="figure"><a id="d0e3341"/><div class="figure-contents"><div class="mediaobject"><img src="OnlyOneCacheLoader.png" alt="2 个节点但是只有一个访问后台存储"/></div></div><p class="title"><b>图 8.3. 2 个节点但是只有一个访问后台存储</b></p></div><br class="figure-break"/><p>这个情况与上一个有点类似，但只是这里集群里只有一个节点通过缓存加载器与后台存储交互。
         所有的其他节点执行内存复制。这里的想法是，所有应用状态保持在每个节点的内存里，
         使存在的多个缓存都能高效提供数据。
         （这里假定需要数据的客户能够以某种方式从一个缓存错误转移到另一个）
         那么，在集群所有缓存失败或需要重启的情况下，单一的持久后台存储提供数据后台备份。
         </p><p>
            这里需要注意，这可能对异步存储修改的缓存加载器有意义，
            为了不降低集群访问（例如）数据库的速度，它<span class="emphasis"><em>没有</em></span>在调用者线程。
            当使用异步复制时，这不是一个问题。
         </p><p>
            这个体系结构的缺点是，带有访问缓存加载器的缓存成为了单点失败源。
            而且，如果集群重启，带有缓存加载器的缓存必须最先启动（很容易忘记）。
            对于第一个问题的一个解决方法是，为每个节点配置一个缓存加载器，
            但是将 <code class="literal">singletonStore</code> 配置设置为 <code class="literal">true</code>。
            在这种设置下，将永远仅有一个节点写入持久存储。
            但是，这么做将使重启问题复杂化，因为启动前，你需要决定关机/故障前哪个缓存正在写入，
            然后最先启动那个缓存。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3362"/>8.5.4. 每个缓存有它自己存储的复制缓存</h3></div></div></div><div class="figure"><a id="d0e3365"/><div class="figure-contents"><div class="mediaobject"><img src="LocalCacheLoader.png" alt="2 个节点，每个有它自己的后台存储"/></div></div><p class="title"><b>图 8.4. 2 个节点，每个有它自己的后台存储</b></p></div><br class="figure-break"/><p>这里，每个节点有它自己数据存储。对缓存的修改是
         （a）跨越集群的复制（b）使用缓存加载器的持久化。
         这意味着所有的数据存储有完全相同的状态。当同步复制修改并在一个事务内时，
         两阶段提交协议保证在每个数据存储内所有的修改都被复制并持久化，
         或者都没有复制和持久化（原子更新）。
         </p><p>注意，JBoss Cache <span class="emphasis"><em>不是</em></span>一个 XA 源，那意味着它没有实现恢复。
         当使用一个支持恢复的事务管理器时，这个功能是不可用的。
         </p><p>这里的挑战是状态的转移：当一个新节点启动时，它需要做下面的事：
         </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>让协调程序（集群中最久的节点）给它发送状态。这总是一个全状态传递，
               覆盖已经存在的任何状态。
               </p></li><li><p>接着，协调程序需要等待直到所有正在执行的事务结束。在这个时间里，
               它不会允许启动新的事务。
               </p></li><li><p>然后，协调程序使用 <code class="literal">loadEntireState()</code> 要求它的缓存加载器返回整个状态。
               随后，它将那个状态发送给新的节点。
               </p></li><li><p>新节点让它的缓存加载器在它的存储中存储那个状态，覆盖旧的状态。
               这使用 <code class="literal">CacheLoader.storeEntireState()</code> 方法。
               </p></li><li><p>状态转移期间，瞬时（内存）状态也可以转移。
               </p></li><li><p>现在与集群里其他节点相比，新节点在它的后台存储里有相同的状态，
               同时，现在使用本地缓存加载器将从其他节点接收的修改持久化了。
               </p></li></ol></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3405"/>8.5.5. 分层的缓存</h3></div></div></div><p>如果你需要在单一 JVM 内建立一个分层结构，你可以使用 <code class="literal">LocalDelegatingCacheLoader</code>。
         当前，这种类型的分层只能通过编程建立。
         </p><p>
            分层的缓存也可以跨越多个 JVM 或服务器使用
            <code class="literal">TcpDelegatingCacheLoader</code> 建立。
            </p><div class="figure"><a id="d0e3418"/><div class="figure-contents"><div class="mediaobject"><img src="DelegatingCacheLoader.png" alt="TCP 委托缓存加载器"/></div></div><p class="title"><b>图 8.5. TCP 委托缓存加载器</b></p></div><p><br class="figure-break"/>

         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3425"/>8.5.6. 多个缓存加载器</h3></div></div></div><p>
            你可以用链的形式建立多个缓存加载器。在内部使用一个委托 <code class="literal">ChainingCacheLoader</code>，
            它引用你配置的每个缓存加载器。
            依据链里使用缓存加载器类型，使用方式会发生变化。
            一个例子就是，为相同主机的 JVM 配置一个基于文件的缓存加载器，用于内存溢出。
            这能保证相对容易地得到数据，而代价又很低。
            一个附加的远程缓存加载器，例如 <code class="literal">TcpDelegatingCacheLoader</code>，
            为服务器重启之间提供恢复。
         </p><div class="figure"><a id="d0e3436"/><div class="figure-contents"><div class="mediaobject"><img src="MultipleCacheLoaders.png" alt="在一个链中的多个缓存加载器"/></div></div><p class="title"><b>图 8.6. 在一个链中的多个缓存加载器</b></p></div><br class="figure-break"/></div></div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="footnotes"><br/><hr/><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e3329" href="#d0e3329">6</a>] </sup>当然，如果他们想在启动后有一个暖或热缓存，他们可以打开状态转移。
               </p></div></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="eviction_policies"/>第 9 章 驱逐策略</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e3450">9.1. 驱逐策略的配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3453">9.1.1. 基本配置</a></span></dt><dt><span class="section"><a href="#d0e3476">9.1.2. 驱逐区域</a></span></dt><dt><span class="section"><a href="#d0e3532">9.1.3. 驻留节点</a></span></dt><dt><span class="section"><a href="#d0e3574">9.1.4. 编程配置</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3607">9.2. 带有的驱逐策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3610">9.2.1. LRUPolicy - 近期最少使用</a></span></dt><dt><span class="section"><a href="#d0e3638">9.2.2. FIFOPolicy - 先进，先出</a></span></dt><dt><span class="section"><a href="#d0e3658">9.2.3. MRUPolicy - 最近使用</a></span></dt><dt><span class="section"><a href="#d0e3678">9.2.4. LFUPolicy - 最少使用</a></span></dt><dt><span class="section"><a href="#d0e3708">9.2.5. ExpirationPolicy</a></span></dt><dt><span class="section"><a href="#d0e3762">9.2.6. ElementSizePolicy - 基于节点里键/值对数量驱逐</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3783">9.3. 编写你自己的驱逐策略</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3786">9.3.1. 驱逐策略插件设计</a></span></dt><dt><span class="section"><a href="#d0e3802">9.3.2. 实现的接口</a></span></dt></dl></dd></dl></div><p>
      驱逐策略通过管理有多少节点允许存储在内存中，以及他们的生命范围来控制着 JBoss Cache 的内存管理。
      服务器上的内存限制决定了它不可能无限增长，因此需要有策略限制缓存的大小。
      驱逐策略绝大多数情况下与<a href="#cache_loaders" title="第 8 章 缓存加载器">缓存加载器</a>一同使用。
   </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3450"/>9.1. 驱逐策略的配置</h2></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3453"/>9.1.1. 基本配置</h3></div></div></div><p>
            基本的驱逐策略配置元素如下：
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;EvictionConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;wakeUpIntervalSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">3</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;This&nbsp;defaults&nbsp;to&nbsp;200000&nbsp;if&nbsp;not&nbsp;specified&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;eventQueueSize&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">100000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Name&nbsp;of&nbsp;the&nbsp;DEFAULT&nbsp;eviction&nbsp;policy&nbsp;class.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;policyClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.eviction.LRUPolicy</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Cache&nbsp;wide&nbsp;default&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/_default_&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">100</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;override&nbsp;policy&nbsp;used&nbsp;for&nbsp;this&nbsp;region&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/org/jboss/data&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">policyClass</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.eviction.LRUPolicy&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">250</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;minTimeToLiveSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">10</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;We&nbsp;expect&nbsp;a&nbsp;lot&nbsp;of&nbsp;events&nbsp;for&nbsp;this&nbsp;region,&nbsp;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;so&nbsp;override&nbsp;the&nbsp;default&nbsp;event&nbsp;queue&nbsp;size&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/org/jboss/test/data&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">eventQueueSize</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;500000&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">60000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;...</span><br />
</pre><p>
            </p><div class="itemizedlist"><ul><li><code class="literal">wakeUpIntervalSeconds</code>
                  - 这个必选的参数定义驱逐线程多少时间运行一次。
               </li><li><code class="literal">eventQueueSize</code>
                  - 这个可选属性定义包含驱逐事件的队列的尺寸。
                  如果你的驱逐线程常常不运行，你可能需要提高这个尺寸。
                  基于每个区域的配置可以覆盖这个参数。
               </li><li><code class="literal">policyClass</code>
                  - 这个参数是必须的，除非你为每个区域设定单独的 policyClass 属性。
                  如果在区域里没有定义，这个参数定义使用的缺省驱逐策略。
               </li></ul></div><p>

         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3476"/>9.1.2. 驱逐区域</h3></div></div></div><p>
            当讨论编码时，区域的概念和 <code class="literal">Region</code> 类
            <a href="#architecture.regions" title="6.6. 类加载和区域">早已浏览过</a>。
            区域也有另外一个用途，就是用于在区域里定义驱逐策略。
            除了用于定义特定区域配置外，你也可以为节点配置一个缺省的、缓存范围的驱逐策略。
            这个驱逐策略不属于预定义的区域，或者你不想定义特定的区域。
            值得关注的一点是，当使用配置 XML 文件定义区域时，
            <code class="literal">Fqn</code> 的所有定义区域元素都是
            <code class="literal">java.lang.String</code> 对象。
         </p><p>
            看看上面的驱逐配置片段，我们看到一个缺省的区域，<code class="literal">_default_</code>，
            包含了应用于不属于任何其他定义区域的节点属性。
         </p><p>
            对于每个区域，你可以定义参数，这些参数将影响应用到区域上的策略如何选择驱逐节点。
            在上面的例子中，<code class="literal">LRUPolicy</code> 允许一个 <code class="literal">maxNodes</code> 参数来定义：
            它选择开始驱逐节点前，区域里可以存在多少节点。
            查看 javadoc，了解每个策略允许的参数列表。
            它也定义一个 <code class="literal">minTimeToLiveSeconds</code> 参数：
            考虑驱逐节点前，节点必须在内存里存在的最少时间。
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3509"/>9.1.2.1. 互相重叠的驱逐区域</h4></div></div></div><p>定义相互重叠的区域是可能的。换句话说，一个区域可以定义成 <span class="emphasis"><em>/a/b/c</em></span>，
            而另一个可以定义成 <span class="emphasis"><em>/a/b/c/d</em></span>
            （它就是 <span class="emphasis"><em>/a/b/c</em></span> 子树的 <span class="emphasis"><em>d</em></span> 子树）。
            为了一致地处理这种情形，算法总选择它遇见的第一个区域。
            在这种模式下，如果算法需要决定如何处理 <span class="emphasis"><em>/a/b/c/d/e</em></span>，
            它将从那开始沿着树向上走，直到它遇到第一个定义区域，在这个例子中是 <span class="emphasis"><em>/a/b/c/d</em></span>。
            </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3532"/>9.1.3. 驻留节点</h3></div></div></div><p>
            标示为驻留的节点（用 <code class="literal">Node.setResident()</code> 接口）在两种情形下都将被驱逐策略忽略，
            这两种情形是：当检查是否触发驱逐；当实际驱逐节点的过程中。
            例如，如果区域配置成最多有 10 个节点，在决定是否驱逐这个区域里的节点时，驻留节点不计算在内。
            另外，当区域的驱逐临界点到达时，也不考虑驱逐驻留节点。
         </p><p>
            为了将一个节点标示驻留，应该使用 <code class="literal">Node.setResident()</code> 接口。
            缺省情况下，新建立的节点都不是驻留的。
            节点的 <code class="literal">resident</code> 属性是不复制、不持久化或不知道事务的。
         </p><p>
            驻留节点的样本用法是，保证“路径”节点不给驱逐策略添加“干扰”。例如：
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_separator">...</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Map</span><span class="java_plain">&nbsp;lotsOfData&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;generateData</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;/a/b/c&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;lotsOfData</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getRoot</span><span class="java_separator">().</span><span class="java_plain">getChild</span><span class="java_separator">(</span><span class="java_literal">&quot;/a&quot;</span><span class="java_separator">).</span><span class="java_plain">setResident</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getRoot</span><span class="java_separator">().</span><span class="java_plain">getChild</span><span class="java_separator">(</span><span class="java_literal">&quot;/a/b&quot;</span><span class="java_separator">).</span><span class="java_plain">setResident</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">...</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
            在这个例子中，节点 <code class="literal">/a</code> 和 <code class="literal">/a/b</code> 都是路径节点，
            它们存在仅仅为了支持节点 <code class="literal">/a/b/c</code>，而且自己不包含任何数据。
            像这样，它们是标示为驻留节点的好候选者。这将导致更好的内存管理，
            因为当访问 <code class="literal">/a</code> 和 <code class="literal">/a/b</code> 时，不会产生驱逐事件。
         </p><p>
            注意：当添加属性到驻留节点时，例如上一个例子中 <code class="literal">cache.put("/a", "k", "v")</code>，
            最好将这些节点再次变成非驻留节点，并考虑驱逐他们。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3574"/>9.1.4. 编程配置</h3></div></div></div><p>
            使用 <code class="literal">Configuration</code> 对象配置驱逐，
            必须使用 <code class="literal">org.jboss.cache.config.EvictionConfig</code> 对象，
            它将传入 <code class="literal">Configuration.setEvictionConfig()</code>。
            查看<a href="#configuration" title="第 3 章 配置">有关配置的章节</a>，
            了解更多编程构建 <code class="literal">Configuration</code> 的信息。
         </p><p>
            使用简单的<a href="#pojo"><em class="glossterm">POJO</em></a> 类来表达所有的缓存配置元素，
            也使在启动缓存后编程添加驱逐区域相当简单。例如，假定我们已经有了一个通过 XML 配置的缓存，
            并且 EvictionConfig 元素象上面显示那样。现在，在运行时，
            我们希望添加一个新的名叫“/org/jboss/fifo”的驱逐区域，使用 <code class="literal">LRUPolicy</code>，
            但是 <code class="literal">maxNodes</code> 数字不同：
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Fqn</span><span class="java_plain">&nbsp;fqn&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">Fqn</span><span class="java_separator">.</span><span class="java_plain">fromString</span><span class="java_separator">(</span><span class="java_literal">&quot;/org/jboss/fifo&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Create</span><span class="java_plain">&nbsp;a&nbsp;configuration&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;an&nbsp;</span><span class="java_type">LRUPolicy</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">LRUConfiguration</span><span class="java_plain">&nbsp;lruc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">LRUConfiguration</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;lruc</span><span class="java_separator">.</span><span class="java_plain">setMaxNodes</span><span class="java_separator">(</span><span class="java_literal">10000</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Create</span><span class="java_plain">&nbsp;the&nbsp;region&nbsp;and&nbsp;set&nbsp;the&nbsp;config</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Region</span><span class="java_plain">&nbsp;region&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getRegion</span><span class="java_separator">(</span><span class="java_plain">fqn</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">true</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;region</span><span class="java_separator">.</span><span class="java_plain">setEvictionPolicy</span><span class="java_separator">(</span><span class="java_plain">lruc</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3607"/>9.2. 带有的驱逐策略</h2></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3610"/>9.2.1. LRUPolicy - 近期最少使用</h3></div></div></div><p>
            <code class="literal">org.jboss.cache.eviction.LRUPolicy</code>
            控制节点生命周期和年龄两个方面。这个策略保证一个恒定顺序（<code class="literal">O (1)</code>）
            添加、移除和查找（访问）。它有下列配置参数：
         </p><div class="itemizedlist"><ul><li><code class="literal">maxNodes</code>
               - 在这个区域里，允许的最大节点数。0 表示没有限制。
            </li><li><code class="literal">timeToLiveSeconds</code>
               - 节点被清除掉以前，节点没有写入或读出的时间量（用秒计）。0 表示没有限制。
            </li><li><code class="literal">maxAgeSeconds</code>
               - 节点被清除掉以前，不考虑空闲时间节点的寿命（用秒计）。0 表示没有限制。
            </li><li><code class="literal">minTimeToLiveSeconds</code>
               - 访问节点后考虑驱逐前，节点必须允许存活的最小时间量。0 表示关闭这个功能，这也是缺省值。
            </li></ul></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3638"/>9.2.2. FIFOPolicy - 先进，先出</h3></div></div></div><p>
            <code class="literal">org.jboss.cache.eviction.FIFOPolicy</code> 以适当的先进先出方式控制驱逐。
            这个策略保证一个恒定的顺序（<code class="literal">O (1)</code>）添加、移除和查找（访问）。
            它有如下的配置参数：
         </p><div class="itemizedlist"><ul><li><code class="literal">maxNodes</code>
               - 在这个区域中，允许的最大节点数。0 表示没有限制。
            </li><li><code class="literal">minTimeToLiveSeconds</code>
               - 访问节点后考虑驱逐前，节点必须允许存活的最小时间量。0 表示关闭这个功能，这也是缺省值。
            </li></ul></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3658"/>9.2.3. MRUPolicy - 最近使用</h3></div></div></div><p>
            <code class="literal">org.jboss.cache.eviction.MRUPolicy</code> 基于最近使用算法控制驱逐。
            在这个策略中，最近使用节点将最先驱逐。这个策略保证一个恒定的顺序（<code class="literal">O (1)</code>）
            添加、移除和查找（访问）。它有下列配置参数：
         </p><div class="itemizedlist"><ul><li><code class="literal">maxNodes</code>
               - 在这个区域中，允许的最大节点数。0 表示没有限制。
            </li><li><code class="literal">minTimeToLiveSeconds</code>
               - 访问节点后考虑驱逐前，节点必须允许存活的最小时间量。0 表示关闭这个功能，这也是缺省值。
            </li></ul></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3678"/>9.2.4. LFUPolicy - 最少使用</h3></div></div></div><p>
            <code class="literal">org.jboss.cache.eviction.LFUPolicy</code> 基于最少使用算法控制驱逐。
            在这个策略中，最少使用的节点将最先驱逐。当节点首先添加时，节点使用数以 1 开始。
            每次访问节点，节点使用数增加 1。这个数字用于决定那个节点是最少使用的。
            <a href="#lfu"><em class="glossterm">LFU</em></a> 也是一个排序驱逐算法。
            底层的 EvictionQueue 实现和算法按照节点访问数的升序排序。
            这个类保证一个恒定顺序（<code class="literal">O (1)</code>）增加、移除和搜索。
            但是，当以给定处理数据途径添加/访问队列里的任意数量节点时，
            以正确的 LFU 顺序用单一的准线性（<code class="literal">O (n * log n)</code>）操作来重新排序队列。
            类似地，如果移除或驱逐任意节点，必须用单一的线性删除操作清除 EvictionQueue。
            LFU 有下列配置参数：
         </p><div class="itemizedlist"><ul><li><code class="literal">maxNodes</code>
               - 在这个区域中，允许的最大节点数。0 表示没有限制。
            </li><li><code class="literal">minNodes</code>
               - 在这个区域中，允许的最小节点数。这个值决定沿着每个路径向下，驱逐队列应用删除什么。
               例如，如果 minNodes 是 10，并且缓存增长到了 100 个节点，当驱逐计时器通过驱逐算法路径时，
               删除缓存到 10 个最常使用的节点。
            </li><li><code class="literal">minTimeToLiveSeconds</code>
               - 访问节点后考虑驱逐前，节点必须允许存活的最小时间量。0 表示关闭这个功能，这也是缺省值。
            </li></ul></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3708"/>9.2.5. ExpirationPolicy</h3></div></div></div><p>
            <code class="literal">org.jboss.cache.eviction.ExpirationPolicy</code> 是一个基于绝对期满时间驱逐节点的策略。
            使用 <code class="literal">org.jboss.cache.Node.put()</code> 方法、
            一个 String 键 <code class="literal">expiration</code> 和
            <code class="literal">java.lang.Long</code> 对象作为绝对时间指明期满时间。
            绝对时间是超过 1970.1.1 午夜后的毫秒 <a href="#utc"><em class="glossterm">UTC</em></a> 时间
            （与 <code class="literal">java.lang.System.currentTimeMillis()</code> 提供的相对时间相同）。
         </p><p>
            这个策略保证一个恒定的顺序（<code class="literal">O (1)</code>）添加和移除。
            在内部，用一个排序集（TreeSet）包含期满时间和存储节点的<a href="#fqn"><em class="glossterm">Fqn</em></a>,
            从基本功能来说是个堆栈。
         </p><p>
            这个策略有下列配置参数：
         </p><div class="itemizedlist"><ul><li><code class="literal">expirationKeyName</code>
               - 这是驱逐算法中使用的节点键名。缺省配置是 <code class="literal">expiration</code>。
            </li><li><code class="literal">maxNodes</code>
               - 在这个区域中，允许的最大节点数。0 表示没有限制。
            </li></ul></div><p>
            下列代码展示如何指明期满日期，以及如何应用策略：
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cache</span><span class="java_plain">&nbsp;cache&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">DefaultCacheFactory</span><span class="java_separator">.</span><span class="java_plain">createCache</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Fqn</span><span class="java_plain">&nbsp;fqn1&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">Fqn</span><span class="java_separator">.</span><span class="java_plain">fromString</span><span class="java_separator">(</span><span class="java_literal">&quot;/node/1&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Long</span><span class="java_plain">&nbsp;future&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Long</span><span class="java_separator">(</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">currentTimeMillis</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">2000</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;sets&nbsp;the&nbsp;expiry&nbsp;time&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;a&nbsp;node</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getRoot</span><span class="java_separator">().</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">fqn1</span><span class="java_separator">).</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_type">ExpirationConfiguration</span><span class="java_separator">.</span><span class="java_plain">EXPIRATION_KEY</span><span class="java_separator">,</span><span class="java_plain">&nbsp;future</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertTrue</span><span class="java_separator">(</span><span class="java_plain">cache</span><span class="java_separator">.</span><span class="java_plain">getRoot</span><span class="java_separator">().</span><span class="java_plain">hasChild</span><span class="java_separator">(</span><span class="java_plain">fqn1</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">Thread</span><span class="java_separator">.</span><span class="java_plain">sleep</span><span class="java_separator">(</span><span class="java_literal">5000</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;after&nbsp;</span><span class="java_literal">5</span><span class="java_plain">&nbsp;seconds</span><span class="java_separator">,</span><span class="java_plain">&nbsp;expiration&nbsp;completes</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;assertFalse</span><span class="java_separator">(</span><span class="java_plain">cache</span><span class="java_separator">.</span><span class="java_plain">getRoot</span><span class="java_separator">().</span><span class="java_plain">hasChild</span><span class="java_separator">(</span><span class="java_plain">fqn1</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span></pre><p>
            注意，只有当区域管理器每隔 <code class="literal">wakeUpIntervalSeconds</code> 醒来时，
            才检查节点的期满时间，因此发生驱逐要比指明的时间稍晚几秒钟。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3762"/>9.2.6. ElementSizePolicy - 基于节点里键/值对数量驱逐</h3></div></div></div><p>
            <code class="literal">org.jboss.cache.eviction.ElementSizePolicy</code> 基于节点里键/值对数量控制驱逐。
            在这个策略里，最近使用的节点将最先驱逐。它有下列配置参数：
         </p><div class="itemizedlist"><ul><li><code class="literal">maxNodes</code>
               - 在这个区域中，允许的最大节点数。0 表示没有限制。
            </li><li><code class="literal">maxElementsPerNode</code>
               - 这是对于选择驱逐的每个节点的触发器数属性。0 表示没有限制。
            </li><li><code class="literal">minTimeToLiveSeconds</code>
               - 访问节点后考虑驱逐前，节点必须允许存活的最小时间量。0 表示关闭这个功能，这也是缺省值。
            </li></ul></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3783"/>9.3. 编写你自己的驱逐策略</h2></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3786"/>9.3.1. 驱逐策略插件设计</h3></div></div></div><p>JBoss Cache 驱逐策略框架设计是基于 <code class="literal">EvictionInterceptor</code> 的，
         用它来处理缓存事件，并转发到驱逐策略。在缓存启动期间，如果声明了驱逐策略，
         将添加一个 <code class="literal">EvictionInterceptor</code> 到缓存的拦截器堆栈。
         然后，一旦添加、移除、驱逐或访问节点，<code class="literal">EvictionInterceptor</code> 将维护状态统计数据，
         并向每个单独驱逐区域转发信息。
         </p><p>
            有一个单独驱逐线程（定时器）在配置的时间间隔运行。
            这个线程将调用提供的每个策略，在配置的间隔期间，
            通知它任意汇总的对缓存的添加、移除和访问（取）事件。
            驱逐线程负责启动每个配置驱逐缓存区域的驱逐策略处理过程（单程）。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3802"/>9.3.2. 实现的接口</h3></div></div></div><p>为了实现一个驱逐策略，必须实现下列接口：
            </p><div class="itemizedlist"><ul><li><code class="literal">org.jboss.cache.eviction.EvictionPolicy</code></li><li><code class="literal">org.jboss.cache.eviction.EvictionAlgorithm</code></li><li><code class="literal">org.jboss.cache.eviction.EvictionQueue</code></li><li><code class="literal">org.jboss.cache.config.EvictionPolicyConfig</code></li></ul></div><p>
            这些接口的每一个实现混合在一起，定义驱逐策略完整实现的所有必须底层机制。
         </p><p>
            <span class="emphasis"><em>注意：</em></span>
         </p><div class="itemizedlist"><ul><li><p>
                  <code class="literal">EvictionPolicyConfig</code> 实现应该维护策略支持的配置属性的
                  getter 和 setter 方法（例如 <code class="literal">LRUConfiguration</code> 其中就包含一个
                  <code class="literal">int getMaxNodes()</code> 和一个 <code class="literal">setMaxNodes(int)</code>）。
                  当 XML 配置的“EvictionConfig”部分解析时，这些属性通过反射设置。
               </p></li></ul></div><p>做为选择，通过扩展 <code class="literal">BaseEvictionPolicy</code>
         和 <code class="literal">BaseEvictionAlgorithm</code>来实现新的驱逐策略可能简单些。
         或者扩展 <code class="literal">BaseSortedEvictionAlgorithm</code> 并实现
            <code class="literal">SortedEvictionQueue</code> 来得到正确的排序驱逐算法
            （驱逐顺序的排序，查看<code class="literal">LFUAlgorithm</code>）。
            这些驱逐策略提供类中已经有很多通用的功能。
         </p><p>
            <span class="emphasis"><em>注意：</em></span>
         </p><div class="itemizedlist"><ul><li><p>
                  <code class="literal">BaseEvictionAlgorithm</code> 类维护一个处理结构。
                  它将先处理的区域的 ADD, REMOVE 和 VISIT 时间队列。
                  它也维护一个，因为持有锁在最后巡视过程中没有正确驱逐的数据集合。
                  那个列是要删除的。最后，基于配置的区域驱逐规则删除 EvictionQueue 自己的数据。
               </p></li><li><p>
                  <code class="literal">BaseSortedEvictionAlgorithm</code> 类通过算法处理将维护一个布尔值，
                  来决定是否添加或访问任意新节点。这允许算法来决定是否重新排序驱逐队列数据（先于驱逐顺序），
                  或者如果这个区域里没有什么修改而跳过潜在地昂贵的排序。
               </p></li><li><p>
                  <code class="literal">SortedEvictionQueue</code> 接口定义由
                  <code class="literal">BaseSortedEvictionAlgorithm</code> 抽象类使用的约定，
                  <code class="literal">BaseSortedEvictionAlgorithm</code> 用于重新排序底层队列。
                  还是那样，队列排序应该先于驱逐顺序。列里的第一个数据应该先于队列里的最后数据驱逐。
                  队列里的最后数据应该是需要驱逐的最后数据。
               </p></li></ul></div></div></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>第 10 章 事务和并发</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e3892">10.1. 并发访问</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3897">10.1.1. 锁</a></span></dt><dt><span class="section"><a href="#d0e3914">10.1.2. 悲观锁</a></span></dt><dt><span class="section"><a href="#d0e3981">10.1.3. 乐观锁</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4052">10.2. 事务支持</a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3892"/>10.1. 并发访问</h2></div></div></div><p>JBoss Cache 是个线程安全的缓存接口，并且使用它自己控制并发的有效机制。
      为了实现高效的目的，缺省情况下它使用悲观锁方案。也可以选择乐观锁，这个在后面讨论。
      </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3897"/>10.1.1. 锁</h3></div></div></div><p>加锁是在内部完成的，在节点的层次。例如，当我们想要访问“/a/b/c”时，
         将获得节点“a”，“b”和“c”的锁。当相同的事务想要访问“/a/b/c/d”时，
         既然我们已经获得了“a”，“b”和“c”的锁，我们只需要获得“d”的锁。
         </p><p>锁的拥有者或者是事务（调用是在一个已经存在的事务范围内进行的）
         或者是线程（调用没有关联事务）。不管是那种情况，在内部都要将事务或线程转换成一个
            <code class="literal">GlobalTransaction</code> 实例，这个实例用做集群范围内修改的全局唯一标识。
            例如，当我们在集群内运行一个两阶段提交协议时，
            <code class="literal">GlobalTransaction</code> 在集群范围内唯一标识工作单元。
         </p><p>锁可以是读锁或写锁。写锁串行化读和写访问，而只读锁仅串行化读访问。
         当得到一个写锁，就不能再得到写或读锁。当得到一个读锁，其他人能得到读锁。
         但是，为了得到写锁，必须等待所有的读锁全部释放掉。
         当预定并发时，写锁总是比读锁优先。注意，（如果打开）读锁可以升级为写锁。
         </p><p>在下面的情景中，使用读-写锁会有帮助：假定有两个节点“/a/b/n1”和“/a/b/n2”的一棵树，
         在写锁的情况下，当 Tx1 访问“/a/b/n1”时，在 Tx1 完成并释放它的锁前 Tx2 不能访问“/a/b/n2”。
         但是，在读-写锁的情况下这是可能的，因为 Tx1 获得“/a/b”的读锁和“/a/b/n1”的读-写锁。
         那么，Tx2 也能够获得“/a/b”的读锁，加上“/a/b/n2”的读-写锁。这将允许更高的缓存并行访问。
         </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3914"/>10.1.2. 悲观锁</h3></div></div></div><p>缺省的情况下，JBoss Cache 使用悲观锁。加锁的操作并不直接暴露给用户。
         而是，通过配置事务隔离层次来提供不同的加锁操作。
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3919"/>10.1.2.1. 隔离层次</h4></div></div></div><p>JBoss Cache 支持下列事务隔离层次，类似于数据库 <a href="#acid"><em class="glossterm">ACID</em></a> 隔离层次。
            用户可以配置实例范围的隔离层次，NONE, READ_UNCOMMITTED, READ_COMMITTED,
               REPEATABLE_READ 或 SERIALIZABLE。缺省情况下隔离层次使用 REPEATABLE_READ。
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>NONE。不需要事务支持。在这个层次没有加锁，例如，用户必须管理数据的完整性。
                  实现中不使用锁。
                  </p></li><li><p>READ_UNCOMMITTED。任意时间都可以读数据，而写操作是互相排斥的。
                  注意，这个层次不能防止所谓的“脏读
                  （<a href="#dirty-read"><em class="glossterm">dirty read</em></a>）”，
                  其中 Tx1 的数据修改在提交前可能被 Tx2 读取。
                  换句话说，如果你有下列次序，
                  </p><pre class="programlisting">
   Tx1     Tx2
    W
            R
</pre><p>
                     使用这个隔离层次将不能防止 Tx2 读操作。一般来说，实现中对写使用排斥锁，而读不需要获得锁。
                  </p></li><li><p>READ_COMMITTED。只要没有写，可以在任意时间读数据。
                  这个层次防止脏读。但是它不能防止所谓的“不可重复读
                  （<a href="#non-repeatable-read"><em class="glossterm">non-repeatable read</em></a>）”，
                  其中可能造成线程两次读取的结果不一致。例如，如果你有下列次序，
                  </p><pre class="programlisting">
   Tx1     Tx2
    R
            W
    R
</pre><p>其中，Tx1 线程里的第二次读将产生不同的结果。
                  </p><p>实现通常使用读-写锁；当只有读的时候，读操作成功获得锁，写操作只有等到没有读锁时才能获得锁。
                  读操作将阻塞等到没有写锁的时候才能获得锁。当完成时，读操作一般释放读锁，
                  这样后续读取相同数据必须重新获得一个读锁，这就导致不可重复读，其中两次读取相同数据可能会有不同的值。
                  注意，不管事务状态（它是否已经提交）如何，写操作只是申请锁。
                  </p></li><li><p>REPEATABLE_READ。只要没有写，数据就可以读，反之亦然。
                  这个层次防止“不可重复读”，但是它不能完全防止所谓的“幻像读
                  （<a href="#phantom-read"><em class="glossterm">phantom read</em></a>）”，
                  其中新数据从其他事务插入树。一般实现使用读-写锁，这是缺省使用的隔离层次。
                  </p></li><li><p>SERIALIZABLE。使用互斥锁同步数据访问。在任意给定时间上，
                  只有 1 个写操作或读操作能够得到锁。锁在事务的终点释放。
                  一般认为这个隔离层次在性能和线程/事务并发方面是非常差的。
                  </p></li></ol></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3962"/>10.1.2.2. 插入和移除节点</h4></div></div></div><p>
               缺省情况下，向树里插入新的节点或从树里移除已经存在节点，
               JBoss Cache 将仅尝试获得新节点父节点的读锁。这个方法并没有将子节点视为父节点状态的完整部分。
               如果节点频繁增加或移除，这个方法允许更高的并发性，但却以准确性的降低为代价。
               当需要更高准确性的时候，JBoss Cache 提供了一个
               <code class="literal">LockParentForChildInsertRemove</code> 配置选项。
               如果将它设为 <code class="literal">true</code>，插入和移除子节点需要获得父节点的
               <span class="emphasis"><em>写锁</em></span>。
            </p><p>
               除了上面所说，在 2.1.0 和更高版本中，JBoss Cache 提供基于每个节点覆盖这个配置的能力。
               查看 <code class="literal">Node.setLockForChildInsertRemove()</code> 和它对应的 javadoc 了解细节。
            </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3981"/>10.1.3. 乐观锁</h3></div></div></div><p>提供乐观锁的动机是为了提高并发。当很多线程大量竞争访问数据树时，
         象我们在悲观锁那样在整个事务期间，对部分树进行加锁（为了读和写）可能非常低效。
         通过使用一种叫做数据版本控制的技术，乐观锁允许线程和事务更高效率的并发。
         版本控制下面解释。注意，如果打开乐观锁，将忽略隔离层次（如果配置）。
         </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3986"/>10.1.3.1. 架构</h4></div></div></div><p>乐观锁将所有的方法都视为事务型的
               <sup>[<a id="d0e3991" href="#ftn.d0e3991">7</a>]</sup>。
               假设你没有在一个进行中事务调用方法，JBoss Cache 也创建一个
               <span class="emphasis"><em>隐含事务</em></span>，当调用结束时，提交这个事务。
               每个事务维护一个事务工作空间，其中包含事务内使用数据的一个拷贝。
            </p><p>例如，如果一个事务调用 <code class="literal">cache.getRoot().getChild( Fqn.fromString("/a/b/c") )</code>，
            节点 a, b 和 c 从主数据树拷贝进工作空间。数据加上版本，并且事务里所有调用都是在这个数据拷贝上工作而不是实际数据。
            当事务提交时，它的工作空间通过比较版本合并回底层树。
            如果有版本不匹配，例如实际数据树版本比工作空间的高，可能是因为其他事务访问了相同的数据，
            修改它并在第一个事务结束前提交了，当提交时，这个事务抛出一个
               <code class="literal">RollbackException</code>异常，并且提交失败。
            </p><p>乐观锁使用我们上面提及的相同的锁，但是锁只保留非常短的时间，在事务的开始建立一个工作空间，
            以及当事务提交时向树合并数据。
            </p><p>
               因此，如果版本检验失败，或者因为比悲观锁运行稍慢，乐观锁会偶尔失败。
               比悲观锁运行稍慢是因为不可避免的开销，以及维护工作空间、数据版本管理和提交验证的额外处理。
               乐观锁在维持一个高水平并发的同时，给你一个接近 SERIALIZABLE 水平的数据完整性。
            </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4010"/>10.1.3.2. 数据版本控制</h4></div></div></div><div class="mediaobject"><img src="DataVersions.png"/></div><p>
               乐观锁使用 <code class="literal">DataVersion</code> 接口（以及一个内部缺省
               <code class="literal">DefaultDataVersion</code> 实现）来跟踪节点的版本。
               在某些情况下，缓存数据是外部数据源，例如数据库的内存数据表达，
               将 JBoss Cache 使用的版本与外部使用的版本协调一致是合理的。
               就这点而论，使用 <a href="#configuration.options" title="3.5. 通过Option API 重新定义配置">options API</a>，
               使用基于每次调用的方法设定你期望的 <code class="literal">DataVersion</code> 是可行的，
               在将你的数据放入缓存前，允许你实现 <code class="literal">DataVersion</code> 接口保存获得的外部版本信息。
            </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4033"/>10.1.3.3. 配置</h4></div></div></div><p>
               通过使用 NodeLockingScheme XML 属性并将其设定为“OPTIMISTIC”打开乐观锁：
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_plain">...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;Node&nbsp;locking&nbsp;scheme:</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;OPTIMISTIC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;PESSIMISTIC&nbsp;(default)</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;NodeLockingScheme&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">OPTIMISTIC</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
</pre><p>
               一般来说，定义带有乐观锁的驱逐策略是个可取的方法，你将驱逐策略的
               <code class="literal">minTimeToLiveSeconds</code> 参数定义得比事务管理器的事务停止时间值稍大。
               在事务进行中
               <sup>[<a id="d0e4045" href="#ftn.d0e4045">8</a>]</sup>
               ，这能保证缓存里的数据版本不被驱逐。
            </p></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4052"/>10.2. 事务支持</h2></div></div></div><p>通过配置，JBoss Cache 可以使用并参与 <a href="#jta"><em class="glossterm">JTA</em></a> 兼容的事务。
      做为选择，如果关闭事务支持，等同于设定为 AutoCommit，其中每次改变（如果打开复制）后，修改都隐含
         <sup>[<a id="d0e4060" href="#ftn.d0e4060">9</a>]</sup>
         复制。
      </p><p>每次调用进来，JBoss Cache 所做的是：</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>返回当前线程关联的 <code class="literal">javax.transaction.Transaction</code>。
            </p></li><li><p>如果还没有，注册一个 <code class="literal">javax.transaction.Synchronization</code>，
            当事务提交或回滚通知事务管理器。
            </p></li></ol></div><p>
         为了这么做，必须提供一个环境的
         <code class="literal">javax.transaction.TransactionManager</code> 引用给缓存。
         通常，通过配置缓存的 <code class="literal">TransactionManagerLookup</code> 接口实现类名来完成。
         当缓存启动时，它将创建这个类的一个实例，并调用它的 <code class="literal">getTransactionManager()</code> 方法，
         这个方法返回一个 <code class="literal">TransactionManager</code> 引用。
      </p><div class="mediaobject"><img src="TransactionLookup.png"/></div><p>JBoss Cache 带有 <code class="literal">JBossTransactionManagerLookup</code> 和
         <code class="literal">GenericTransactionManagerLookup</code>。
         <code class="literal">JBossTransactionManagerLookup</code> 能够绑定到一个运行的 JBoss AS 实例，
         并返回一个 <code class="literal">TransactionManager</code>，
         而 <code class="literal">GenericTransactionManagerLookup</code> 能绑定到很多流行的 Java EE 应用服务器，
         并提供相同的功能。也提供一个伪实现 <code class="literal">DummyTransactionManagerLookup</code>，
         主要用于单元测试。因为是伪实现，它仅用于演示和测试目的，不推荐在产品中使用。
      </p><p>
         配置 <code class="literal">TransactionManagerLookup</code> 的另一个方法是，编程注入一个
         <code class="literal">TransactionManager</code> 引用到
         <code class="literal">Configuration</code> 对象的
         <code class="literal">RuntimeConfig</code> 元素：
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_type">TransactionManager</span><span class="java_plain">&nbsp;tm&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;getTransactionManager</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;magic&nbsp;method</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;cache</span><span class="java_separator">.</span><span class="java_plain">getConfiguration</span><span class="java_separator">().</span><span class="java_plain">getRuntimeConfig</span><span class="java_separator">().</span><span class="java_plain">setTransactionManager</span><span class="java_separator">(</span><span class="java_plain">tm</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
         当 <code class="literal">Configuration</code> 是通过某种 <a href="#ioc"><em class="glossterm">IOC</em></a> 容器构建的，
         并且已经有了一个对事务管理器的引用，
         注入 <code class="literal">TransactionManager</code> 是推荐的方法。
      </p><p>当事务提交时，我们启动一个一阶段或二阶段提交协议。
      查看<a href="#replication.tx" title="7.1.2.1. 复制的缓存和事务">复制缓存和事务</a>，了解细节。
      </p></div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="footnotes"><br/><hr/><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e3991" href="#d0e3991">7</a>] </sup>因为这个需求，当使用乐观锁时，你必须总是配置一个事务管理器。
                  </p></div><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e4045" href="#d0e4045">8</a>] </sup>查看
                     <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jira.jboss.com/jira/browse/JBCACHE-1155">JBCACHE-1155</a>
                  </p></div><div xmlns="http://www.w3.org/1999/xhtml" class="footnote"><p><sup>[<a id="ftn.d0e4060" href="#d0e4060">9</a>] </sup>依赖于是否使用基于内部的异步复制。</p></div></div></div></div><div class="part" lang="zh-CN"><div class="titlepage"><div><div><h1 class="title"><a id="d0e4148"/>部分 III. JBoss Cache 参考配置</h1></div></div></div><div class="partintro" lang="zh-CN"><div/><p>
            这个章节的主要内容是技术参考，是为了查找方便。
         </p><div class="toc"><p><b>目录</b></p><dl><dt><span class="chapter"><a href="#configuration_reference_chapter">11. 参考配置</a></span></dt><dd><dl><dt><span class="section"><a href="#sample_xml_file">11.1. XML 配置文件例子</a></span></dt><dt><span class="section"><a href="#configuration_reference">11.2. XML 属性参考表</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jmx_reference">12. JMX 参考</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx_reference.statistics">12.1. JBoss Cache 统计数据</a></span></dt><dt><span class="section"><a href="#jmx_reference.notifications">12.2. JMX MBean 通知</a></span></dt></dl></dd></dl></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration_reference_chapter"/>第 11 章 参考配置</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#sample_xml_file">11.1. XML 配置文件例子</a></span></dt><dt><span class="section"><a href="#configuration_reference">11.2. XML 属性参考表</a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="sample_xml_file"/>11.1. XML 配置文件例子</h2></div></div></div><p>
         这是典型 XML 配置文件的样子。推荐你使用 JBoss Cache 发布程序带有的配置文件，
         然后根据自己的需求做些调整，而不是从头写一个配置文件。
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;=====================================================================&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;&nbsp;Sample&nbsp;JBoss&nbsp;Cache&nbsp;Service&nbsp;Configuration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&lt;!--&nbsp;=====================================================================&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;====================================================================&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Defines&nbsp;JBoss&nbsp;Cache&nbsp;configuration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;====================================================================&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Note&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;'code'&nbsp;attribute&nbsp;has&nbsp;changed&nbsp;since&nbsp;JBC&nbsp;1.x&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">mbean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">code</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.cache.jmx.CacheJmxWrapper&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;jboss.cache:service=Cache&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Ensure&nbsp;JNDI&nbsp;and&nbsp;the&nbsp;TransactionManager&nbsp;are&nbsp;started&nbsp;before&nbsp;the</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.&nbsp;&nbsp;Only&nbsp;works&nbsp;inside&nbsp;JBoss&nbsp;AS;&nbsp;ignored&nbsp;otherwise&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">jboss:service=Naming</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">jboss:service=TransactionManager</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Configure&nbsp;the&nbsp;TransactionManager&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TransactionManagerLookupClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.jboss.cache.transaction.GenericTransactionManagerLookup</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Node&nbsp;locking&nbsp;level&nbsp;:&nbsp;SERIALIZABLE</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPEATABLE_READ&nbsp;(default)</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;READ_COMMITTED</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;READ_UNCOMMITTED</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;IsolationLevel&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">REPEATABLE_READ</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Lock&nbsp;parent&nbsp;before&nbsp;doing&nbsp;node&nbsp;additions/removes&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;LockParentForChildInsertRemove&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Valid&nbsp;modes&nbsp;are&nbsp;LOCAL&nbsp;(default)</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPL_ASYNC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPL_SYNC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INVALIDATION_ASYNC</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INVALIDATION_SYNC&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheMode&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">REPL_ASYNC</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Name&nbsp;of&nbsp;cluster.&nbsp;Needs&nbsp;to&nbsp;be&nbsp;the&nbsp;same&nbsp;for&nbsp;all&nbsp;JBoss&nbsp;Cache&nbsp;nodes&nbsp;in&nbsp;a</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cluster&nbsp;in&nbsp;order&nbsp;to&nbsp;find&nbsp;each&nbsp;other.&nbsp;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ClusterName&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">JBossCache-Cluster</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--Uncomment&nbsp;next&nbsp;three&nbsp;statements&nbsp;to&nbsp;use&nbsp;the&nbsp;JGroups&nbsp;multiplexer.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;configuration&nbsp;is&nbsp;dependent&nbsp;on&nbsp;the&nbsp;JGroups&nbsp;multiplexer&nbsp;being</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;registered&nbsp;in&nbsp;an&nbsp;MBean&nbsp;server&nbsp;such&nbsp;as&nbsp;JBossAS.&nbsp;&nbsp;This&nbsp;type&nbsp;of</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dependency&nbsp;injection&nbsp;only&nbsp;works&nbsp;in&nbsp;the&nbsp;AS;&nbsp;outside&nbsp;it's&nbsp;up&nbsp;to</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;your&nbsp;code&nbsp;to&nbsp;inject&nbsp;a&nbsp;ChannelFactory&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;use&nbsp;one.&nbsp;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;depends&nbsp;optional-attribute-name=&quot;MultiplexerService&quot;&nbsp;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy-type=&quot;attribute&quot;&gt;jgroups.mux:name=Multiplexer&lt;/depends&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&nbsp;name=&quot;MultiplexerStack&quot;&gt;tcp&lt;/attribute&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;JGroups&nbsp;protocol&nbsp;stack&nbsp;properties.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClusterConfig&nbsp;isn't&nbsp;used&nbsp;if&nbsp;the&nbsp;multiplexer&nbsp;is&nbsp;enabled&nbsp;above.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ClusterConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;UDP:&nbsp;if&nbsp;you&nbsp;have&nbsp;a&nbsp;multihomed&nbsp;machine,&nbsp;set&nbsp;the&nbsp;bind_addr&nbsp;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attribute&nbsp;to&nbsp;the&nbsp;appropriate&nbsp;NIC&nbsp;IP&nbsp;address&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;UDP:&nbsp;On&nbsp;Windows&nbsp;machines,&nbsp;because&nbsp;of&nbsp;the&nbsp;media&nbsp;sense&nbsp;feature</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;being&nbsp;broken&nbsp;with&nbsp;multicast&nbsp;(even&nbsp;after&nbsp;disabling&nbsp;media&nbsp;sense)</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;the&nbsp;loopback&nbsp;attribute&nbsp;to&nbsp;true&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">UDP</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">mcast_addr</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;228.1.2.3&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">mcast_port</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;48866&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">ip_ttl</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;64&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">ip_mcast</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">mcast_send_buf_size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;150000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">mcast_recv_buf_size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;80000&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">ucast_send_buf_size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;150000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">ucast_recv_buf_size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;80000&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">loopback</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">PING</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">timeout</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;2000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">num_initial_members</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;3&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">MERGE2</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">min_interval</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;10000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">max_interval</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;20000&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">FD</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">shun</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">FD_SOCK</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">VERIFY_SUSPECT</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">timeout</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;1500&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">pbcast.NAKACK</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">gc_lag</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;50&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">retransmit_timeout</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;600,1200,2400,4800&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">UNICAST</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">timeout</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;600,1200,2400&quot;</span><span class="xml_plain">,4800</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">pbcast.STABLE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">desired_avg_gossip</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;400000&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">FC</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">max_credits</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;2000000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">min_threshold</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;0.10&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">FRAG2</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">frag_size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;8192&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">pbcast.GMS</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">join_timeout</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;5000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">shun</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">print_local_addr</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">pbcast.STATE_TRANSFER</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;max&nbsp;amount&nbsp;of&nbsp;time&nbsp;(in&nbsp;milliseconds)&nbsp;we&nbsp;wait&nbsp;until&nbsp;the</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial&nbsp;state&nbsp;(ie.&nbsp;the&nbsp;contents&nbsp;of&nbsp;the&nbsp;cache)&nbsp;are&nbsp;retrieved&nbsp;from</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;existing&nbsp;members&nbsp;in&nbsp;a&nbsp;clustered&nbsp;environment</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;StateRetrievalTimeout&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">20000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;milliseconds&nbsp;to&nbsp;wait&nbsp;until&nbsp;all&nbsp;responses&nbsp;for&nbsp;a</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronous&nbsp;call&nbsp;have&nbsp;been&nbsp;received.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;SyncReplTimeout&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">20000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Max&nbsp;number&nbsp;of&nbsp;milliseconds&nbsp;to&nbsp;wait&nbsp;for&nbsp;a&nbsp;lock&nbsp;acquisition&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;LockAcquisitionTimeout&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">15000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Shutdown&nbsp;hook&nbsp;behavior.&nbsp;&nbsp;Valid&nbsp;choices&nbsp;are:&nbsp;DEFAULT,&nbsp;REGISTER&nbsp;and&nbsp;DONT_REGISTER.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;this&nbsp;element&nbsp;is&nbsp;omitted,&nbsp;DEFAULT&nbsp;is&nbsp;used.&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ShutdownHookBehavior&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">DEFAULT</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Enables&nbsp;or&nbsp;disables&nbsp;lazy&nbsp;unmarshalling.&nbsp;&nbsp;If&nbsp;omitted,&nbsp;the&nbsp;default&nbsp;is&nbsp;that&nbsp;lazy&nbsp;unmarshalling&nbsp;is&nbsp;enabled.&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;UseLazyDeserialization&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Specific&nbsp;eviction&nbsp;policy&nbsp;configurations.&nbsp;This&nbsp;is&nbsp;LRU&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;EvictionConfig&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;wakeUpIntervalSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;This&nbsp;defaults&nbsp;to&nbsp;200000&nbsp;if&nbsp;not&nbsp;specified&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;eventQueueSize&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">200000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;policyClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.cache.eviction.LRUPolicy</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Cache&nbsp;wide&nbsp;default&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/_default_&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;timeToLiveSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">1000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/org/jboss/data&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;timeToLiveSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">1000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/org/jboss/test/data&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;timeToLiveSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">4</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/test&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">10000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;timeToLiveSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">4</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">region</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;/maxAgeTest&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxNodes&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">10000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;timeToLiveSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">8</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;maxAgeSeconds&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">10</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">region</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">config</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">mbean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration_reference"/>11.2. XML 属性参考表</h2></div></div></div><p>这是上面使用的每个 XML 属性定义列表。如果属性状态描述是<span class="emphasis"><em>动态的</em></span>，
      则意味着缓存创建和启动后也可以修改。
      </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
                     <p>名称</p>
                  </td><td>
                     <p>描述</p>
                  </td></tr><tr><td>
                     <p>BuddyReplicationConfig</p>
                  </td><td>
                     <p>一个包含详细伙伴复制配置的 XML 元素。
                     查看<a href="#br" title="7.1.2.2. 伙伴复制">伙伴复制部分</a>，了解详细内容。
                     </p>
                  </td></tr><tr><td>
                     <p>CacheLoaderConfig</p>
                  </td><td>
                     <p>一个包含详细缓存加载器配置的 XML 元素。
                     查看<a href="#cache_loaders" title="第 8 章 缓存加载器">缓存加载器章节</a>，了解详细内容。
                     </p>
                  </td></tr><tr><td>
                     <p>CacheLoaderConfiguration</p>
                  </td><td>
                     <p>
                        <span class="emphasis"><em>不推荐使用</em></span>。使用 <code class="literal">CacheLoaderConfig</code>。
                     </p>
                  </td></tr><tr><td>
                     <p>CacheMode</p>
                  </td><td>
                     <p>LOCAL, REPL_SYNC, REPL_ASYNC, INVALIDATION_SYNC 或 INVALIDATION_ASYNC。
                     缺省是 LOCAL。查看<a href="#clustering" title="第 7 章 集群">集群章节</a>，了解详细信息。
                     </p>
                  </td></tr><tr><td>
                     <p>ClusterConfig</p>
                  </td><td>
                     <p>配置底层 JGroups 堆栈。如果使用 <code class="literal">MultiplexerService</code>
                        和 <code class="literal">MultiplexerStack</code>，则忽略。
                        查看发布的源代码
                        <code class="literal">resources/config-samples</code> 目录下的各种 *-service.xml 样本文件。
                        查看 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jgroups.org">JGroups 文档</a>
                        或者
                        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups">JGroups wiki 页</a>，
                        了解更详细信息。
                     </p>
                  </td></tr><tr><td>
                     <p>ClusterName</p>
                  </td><td>
                     <p>集群名。为了节点之间相互通信，要求集群中所有节点的集群名都相同。
                     </p>
                  </td></tr><tr><td>
                     <p>EvictionPolicyConfig</p>
                  </td><td>
                     <p>指定驱逐策略的配置参数。
                        查看<a href="#eviction_policies" title="第 9 章 驱逐策略">驱逐策略章节</a>，
                        了解详细信息。这个属性是<span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>ExposeManagementStatistics</p>
                  </td><td>
                     <p>
                        指定提供统计数据的拦截器在启动时是否打开收集统计数据的开关。
                        也控制是否向拦截器链添加 <code class="literal">CacheMgmtInterceptor</code>
                        （它的唯一目的是收集统计数据）。缺省值是 <span class="emphasis"><em>true</em></span>。
                        查看 <a href="#jmx.statistics" title="4.5.3. JBoss Cache 统计数据">JBoss Cache 统计数据部分</a>，
                        了解详细信息。
                     </p>
                  </td></tr><tr><td>
                     <p>FetchInMemoryState
                     </p>
                  </td><td>
                     <p>是否从已经存在的成员获得初始内存状态。
                     当打开这个开关时，允许热缓存。还要参考 <code class="literal">CacheLoaderConfig</code> 里的
                        <code class="literal">fetchPersistentState</code> 元素。
                        缺省值是 <code class="literal">true</code>。这个属性是<span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>InactiveOnStartup</p>
                  </td><td>
                     <p>在启动时，整个树是否是不活跃，只对调用
                        <code class="literal">activateRegion()</code> 激活树的一个或多个部分后反应复制信息。
                        如果是 true，忽略 <code class="literal">FetchInMemoryState</code> 属性。
                        只有在 <code class="literal">UseRegionBasedMarshalling</code> 也是 <code class="literal">true</code>的情况下，
                        这个属性才应该设置为 true。
                     </p>
                  </td></tr><tr><td>
                     <p>StateRetrievalTimeout</p>
                  </td><td>
                     <p>等待取回状态的时间，毫秒计。
                     这个时间应该比 <code class="literal">LockAcquisitionTimeout</code> 长，
                     因为提供状态的节点需要等待这么长的时间，以获得必要的缓存读锁。
                     这个属性是<span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>IsolationLevel</p>
                  </td><td>
                     <p>节点的加锁隔离层次：SERIALIZABLE, REPEATABLE_READ
                     （缺省的）, READ_COMMITTED, READ_UNCOMMITTED 和 NONE。
                     注意，如果 NodeLockingScheme 是 OPTIMISTIC，则忽略这个属性，不会造成什么麻烦。
                     查看有关事务和并发的文档，了解详细信息。
                     </p>
                  </td></tr><tr><td>
                     <p>LockAcquisitionTimeout</p>
                  </td><td>
                     <p>等待获得锁的时间，毫秒计。
                     如果不能获得一个锁，则抛出一个异常。这个属性是<span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>LockParentForChildInsertRemove</p>
                  </td><td>
                     <p>控制插入或移除一个节点时是否需要获得父节点的写锁（当使用悲观锁时），
                     或者是否导致父节点版本的更新（当使用乐观锁时）。缺省值是 <code class="code">false</code>。
                     </p>
                  </td></tr><tr><td>
                     <p>MarshallerClass</p>
                  </td><td>
                     <p>用一个 <code class="literal">org.jboss.cache.marshall.Marshaller</code> 实例串行化数据为字节流。
                     如果没有指定，缺省是 <code class="literal">org.jboss.cache.marshall.VersionAwareMarshaller</code>。
                     </p>
                  </td></tr><tr><td>
                     <p>MultiplexerService</p>
                  </td><td>
                     <p>定义 JGroups 多路器的 JMX 服务对象名。在 JBoss AS 5.0 中，
                     这个服务一般定义在 jgroups-multiplexer.sar 中。
                     这个 XML 属性只能由 JBoss AS MBean 部署服务来处理。
                     如果将它包含在一个文件里传递给 <code class="literal">CacheFactory</code>，创建缓存工厂将失败。
                     在 JBoss AS 中，应该使用“depends optional-attribute-name”的语法形式定义属性，
                     象上面显示的例子一样。在 AS 中，如果定义了这个属性，
                     将在 <code class="literal">CacheJmxWrapper</code> 中插入一个
                    <code class="literal">org.jgroups.jmx.JChannelFactoryMBean</code> 实例，
                    <code class="literal">CacheJmxWrapper</code> 用它获得多路 JGroups 通道。
                    通道的配置将与 <code class="literal">MultiplexerStack</code> 关联。
                    <code class="literal">ClusterConfig</code> 属性将被忽略。
                     </p>
                  </td></tr><tr><td>
                     <p>MultiplexerStack</p>
                  </td><td>
                     <p>用于缓存集群的 JGroups 堆栈名。
                     堆栈在上面讨论的外部 <code class="literal">MultiplexerService</code> 配置中定义。
                     在 JBoss AS 5 中，一般在 jgroups-multiplexer.sar/META-INF/multiplexer-stacks.xml 文件中完成。
                     缺省堆栈是 <code class="literal">udp</code>。这个属性与 <code class="literal">MultiplexerService</code> 联合使用。
                     </p>
                  </td></tr><tr><td>
                     <p>NodeLockingScheme</p>
                  </td><td>
                     <p>可以是 PESSIMISTIC （缺省）或 OPTIMISTIC。
                     </p>
                  </td></tr><tr><td>
                     <p>ReplicationVersion</p>
                  </td><td>
                     <p>让缓存以 JBoss Cache 给定版本使用的格式串行化集群数据流。
                     不同 JBoss Cache 版本使用不同的报文格式，
                     设定这个属性让缓存从一个较新版本用较早版本的格式串行化数据。
                     这允许缓存的不同版本互相操作。例如，一个 2.1.0 缓存能够将这个值设为“2.0.0”，
                     允许它与一个 2.0.0 缓存互操作。有效值是用点符号隔开的版本数字，
                     最后的名字也是用点符号隔开的，例如“2.0.0”或“2.0.0.GA”。
                     在 2.x 系列中，不支持 1.x 版本表达的值。
                     </p>
                  </td></tr><tr><td>
                     <p>ReplQueueInterval</p>
                  </td><td>
                     <p>元素从复制队列到被复制的时间，毫秒计。
                     只有在打开 <code class="literal">UseReplQueue</code> 时使用。
                     这个属性是<span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>ReplQueueMaxElements</p>
                  </td><td>
                     <p>直到弹出复制为止，复制队列的最大元素数。
                     只有在打开 <code class="literal">UseReplQueue</code>时使用。
                     这个属性是<span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>SyncCommitPhase</p>
                  </td><td>
                     <p>当使用 REPL_SYNC （对其他缓存模式不起作用）时，
                     用这个选项控制 2 阶段提交协议提交部分的动作。
                     缺省情况下设置为 <code class="literal">false</code>。
                     打开这个选项会有性能上的损失，特别是在大的集群里运行，
                     但是有利的一面是集群范围数据完整性的提高。
                     查看有关集群缓存的章节，了解这方面的详细信息。
                     这个属性是<span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>SyncReplTimeout</p>
                  </td><td>
                     <p>对于同步复制：等待集群里所有节点都确认收到复制的时间，毫秒计。
                     通常最好比 <code class="literal">LockAcquisitionTimeout</code> 大。
                     这个属性是 <span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>SyncRollbackPhase</p>
                  </td><td>
                     <p>当使用 REPL_SYNC（对于其他缓存模式不起作用）时，
                     这个选项用于控制 2 阶段提交协议回滚部分的行为。
                     缺省值设为 <code class="literal">false</code>。
                     打开这个选项会有性能上的损失，特别是在大的集群里运行，
                     但是有利的一面是集群范围数据完整性的提高。
                     查看有关集群缓存的章节，了解这方面的详细信息。
                     这个属性是<span class="emphasis"><em>动态的</em></span>。
                     </p>
                  </td></tr><tr><td>
                     <p>TransactionManagerLookupClass</p>
                  </td><td>
                     <p>实现 TransactionManagerLookup 的类的全限定名。
                     缺省是 JBossTransactionManagerLookup。
                     例如，还有一个 GenericTransactionManagerLookup 选项。
                     </p>
                  </td></tr><tr><td>
                     <p>UseInterceptorMbeans</p>
                  </td><td>
                     <p>
                        <span class="emphasis"><em>不推荐使用。</em></span>
                        使用 <code class="literal">ExposeManagementStatistics</code>。
                     </p>
                  </td></tr><tr><td>
                     <p>UseRegionBasedMarshalling</p>
                  </td><td>
                     <p>当解码复制数据时，这个选项指定对于不同缓存区域是否支持使用不同类加载器。
                     如果没有说明，缺省是 <code class="literal">false</code>。
                     </p>
                     <p>
                        DEPRECATED 这个选项在 JBoss Cache 3.x 里会消失。
                        查看替代的 <code class="literal">UseLazyDeserialization</code>。
                     </p>
                  </td></tr><tr><td>
                     <p>UseReplQueue</p>
                  </td><td>
                     <p>对于异步复制：是否使用复制队列。缺省是 <code class="literal">false</code>。
                     </p>
                  </td></tr><tr><td>
                     <p>ShutdownHookBehavior</p>
                  </td><td>
                     <p>一个可选参数，控制 JBoss Cache 是否注册一个 JVM 运行时的关闭钩子。
                     允许的值是 <code class="literal">DEFAULT</code>,<code class="literal">REGISTER</code>
                     和 <code class="literal">DONT_REGISTER</code>。
                     <code class="literal">REGISTER</code> 和 <code class="literal">DONT_REGISTER</code>
                     分别强制或禁止注册关闭钩子，
                     如果没有找到 MBean 服务器（不是缺省的 JDK）并且假定是在一个受管理的环境中运行，
                     <code class="literal">DEFAULT</code>将注册一个。
                     象期望的那样，如果没有说明，缺省是<code class="literal">DEFAULT</code>。
                     </p>
                  </td></tr><tr><td>
                     <p>UseLazyDeserialization</p>
                  </td><td>
                     <p>一个可选的参数，可以用于打开或关闭缓存对象迟反串行化的使用。
                     缺省是 <code class="literal">false</code>，这要增加一个小的开销处理。
                     如果关闭迟反串行化，在调用线程离开时，隐含支持使用注册的环境类加载器。
                     </p>
                  </td></tr><tr><td>
                     <p>ObjectInputStreamPoolSize 和 ObjectOutputStreamPoolSize</p>
                  </td><td>
                     <p>
                        自从 JBoss Cache 2.1.0 开始，集群中用于串行化和反串行化 RPC 调用的对象输入和输出流，
                        都被集中起来，减少构造这些流的开销。通过使用特殊的可重放流实现来重用他们。
                     </p>
                     <p>
                        缺省情况下，这些流池每个设为 <code class="literal">50</code> 对象。
                        如果程序分析时你看到很多线程阻塞在
                        <code class="literal">ObjectStreamPool.getInputStream()</code>
                        或 <code class="literal">ObjectStreamPool.getOutputStream()</code>，
                        你可以增加或减少池的尺寸。
                        一般来说，拥有更多的流比少于所需更好。
                        基于你应用程序的情况，来保证你可用的流数量比你希望并发写缓存的线程数量多。
                     </p>
                  </td></tr></tbody></table></div></div></div><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="jmx_reference"/>第 12 章 JMX 参考</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#jmx_reference.statistics">12.1. JBoss Cache 统计数据</a></span></dt><dt><span class="section"><a href="#jmx_reference.notifications">12.2. JMX MBean 通知</a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="jmx_reference.statistics"/>12.1. JBoss Cache 统计数据</h2></div></div></div><p>
         下表描述当前可用并能够通过 JMX 收集的统计数据。
      </p><div class="table"><a id="d0e4733"/><p class="title"><b>表 12.1. JBoss Cache 管理统计数据</b></p><div class="table-contents"><table summary="JBoss Cache 管理统计数据" border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th>MBean 名</th><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>ActivationInterceptor</td><td>Activations</td><td>long</td><td>钝化节点被激活的数量。</td></tr><tr><td>CacheLoaderInterceptor</td><td>CacheLoaderLoads</td><td>long</td><td>通过缓存加载器加载的节点数量。</td></tr><tr><td>CacheLoaderInterceptor</td><td>CacheLoaderMisses</td><td>long</td><td>尝试通过缓存加载器加载节点的失败次数。</td></tr><tr><td>CacheMgmtInterceptor</td><td>Hits</td><td>long</td><td>成功取回属性的数量。</td></tr><tr><td>CacheMgmtInterceptor</td><td>Misses</td><td>long</td><td>没有成功取回属性的数量。</td></tr><tr><td>CacheMgmtInterceptor</td><td>Stores</td><td>long</td><td>属性存储操作的数量。</td></tr><tr><td>CacheMgmtInterceptor</td><td>Evictions</td><td>long</td><td>驱逐节点的数量。</td></tr><tr><td>CacheMgmtInterceptor</td><td>NumberOfAttributes</td><td>int</td><td>当前缓存属性数。</td></tr><tr><td>CacheMgmtInterceptor</td><td>NumberOfNodes</td><td>int</td><td>当前缓存节点数。</td></tr><tr><td>CacheMgmtInterceptor</td><td>ElapsedTime</td><td>long</td><td>缓存已经运行秒数。</td></tr><tr><td>CacheMgmtInterceptor</td><td>TimeSinceReset</td><td>long</td><td>从缓存统计数据重置算起的秒数。</td></tr><tr><td>CacheMgmtInterceptor</td><td>AverageReadTime</td><td>long</td><td>取回缓存属性的平均时间，毫秒计，包括不成功的属性取回。
                  </td></tr><tr><td>CacheMgmtInterceptor</td><td>AverageWriteTime</td><td>long</td><td>写入缓存属性的平均时间，毫秒计。</td></tr><tr><td>CacheMgmtInterceptor</td><td>HitMissRatio</td><td>double</td><td>成功与成功和失败的比例。一个成功是返回对象给客户的取属性操作。
                  如果数据没有在本地缓存里，也可能从缓存加载器取回。
                  </td></tr><tr><td>CacheMgmtInterceptor</td><td>ReadWriteRatio</td><td>double</td><td>读操作与写操作的比例。这是缓存成功和失败与缓存存储的比例。
                  </td></tr><tr><td>CacheStoreInterceptor</td><td>CacheLoaderStores</td><td>long</td><td>写入缓存加载器的节点数量。</td></tr><tr><td>InvalidationInterceptor</td><td>Invalidations</td><td>long</td><td>已经失效的缓存节点数量。</td></tr><tr><td>PassivationInterceptor</td><td>Passivations</td><td>long</td><td>已经钝化的缓存节点数量。</td></tr><tr><td>TxInterceptor</td><td>Prepares</td><td>long</td><td>通过这个拦截器完成的事务准备操作数。</td></tr><tr><td>TxInterceptor</td><td>Commits</td><td>long</td><td>通过这个拦截器完成的事务提交操作数。</td></tr><tr><td>TxInterceptor</td><td>Rollbacks</td><td>long</td><td>通过这个拦截器完成的事务回滚操作数。</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="jmx_reference.notifications"/>12.2. JMX MBean 通知</h2></div></div></div><p>下表描述 JBoss Cache 可用的 JMX 通知，也包括它们对应的缓存事件。
      这些是可以通过 <code class="literal">CacheJmxWrapper</code> MBean 接到的通知。
      每个通知表达 JBoss Cache 发布的单一事件，以及提供的对应事件参数的用户数据。
      </p><div class="table"><a id="d0e4949"/><p class="title"><b>表 12.2. JBoss Cache MBean 通知</b></p><div class="table-contents"><table summary="JBoss Cache MBean 通知" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>通知类型</th><th>通知数据</th><th>CacheListener 事件</th></tr></thead><tbody><tr><td>org.jboss.cache.CacheStarted</td><td>String : 缓存服务名</td><td>cacheStarted</td></tr><tr><td>org.jboss.cache.CacheStopped</td><td>String : 缓存服务名</td><td>cacheStopped</td></tr><tr><td>org.jboss.cache.NodeCreated</td><td>String : fqn</td><td>NodeCreated</td></tr><tr><td>org.jboss.cache.NodeEvicted</td><td>String : fqn</td><td>NodeEvicted</td></tr><tr><td>org.jboss.cache.NodeLoaded</td><td>String : fqn</td><td>NodeLoaded</td></tr><tr><td>org.jboss.cache.NodeModifed</td><td>String : fqn</td><td>NodeModifed</td></tr><tr><td>org.jboss.cache.NodeRemoved</td><td>String : fqn</td><td>NodeRemoved</td></tr><tr><td>org.jboss.cache.NodeVisited</td><td>String : fqn</td><td>NodeVisited</td></tr><tr><td>org.jboss.cache.ViewChange</td><td>String : view</td><td>ViewChange</td></tr><tr><td>org.jboss.cache.NodeActivate</td><td><table width="100%" border="0"><colgroup><col/></colgroup><tbody><tr><td>Object[0]=String: fqn</td></tr><tr><td>Object[1]=Boolean: pre</td></tr></tbody></table></td><td>NodeActivate</td></tr><tr><td>org.jboss.cache.NodeEvict</td><td><table width="100%" border="0"><colgroup><col/></colgroup><tbody><tr><td>Object[0]=String: fqn</td></tr><tr><td>Object[1]=Boolean: pre</td></tr></tbody></table></td><td>NodeEvict</td></tr><tr><td>org.jboss.cache.NodeModify</td><td><table width="100%" border="0"><colgroup><col/></colgroup><tbody><tr><td>Object[0]=String: fqn</td></tr><tr><td>Object[1]=Boolean: pre</td></tr><tr><td>Object[2]=Boolean: isLocal</td></tr></tbody></table></td><td>NodeModify</td></tr><tr><td>org.jboss.cache.NodePassivate</td><td><table width="100%" border="0"><colgroup><col/></colgroup><tbody><tr><td>Object[0]=String: fqn</td></tr><tr><td>Object[1]=Boolean: pre</td></tr></tbody></table></td><td>NodePassivate</td></tr><tr><td>org.jboss.cache.NodeRemove</td><td><table width="100%" border="0"><colgroup><col/></colgroup><tbody><tr><td>Object[0]=String: fqn</td></tr><tr><td>Object[1]=Boolean: pre</td></tr><tr><td>Object[2]=Boolean: isLocal</td></tr></tbody></table></td><td>NodeRemove</td></tr></tbody></table></div></div><br class="table-break"/></div></div></div><div class="glossary"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5096"/>术语表</h2></div></div></div><div class="glossdiv"><h3 class="title">A</h3><dl><dt><a id="acid"/>ACID</dt><dd><p>指数据库的不可部分完成性（又称「原子性」，Atomicity）、一致性（Consistency）、
                隔离性（Isolation）、持久性（Durability）。</p></dd><dt><a id="api_gloss"/>API</dt><dd><p>Application Programming Interface，应用编程接口。</p></dd><dt><a id="as"/>AS</dt><dd><p>Application Server，应用服务器。</p></dd></dl></div><div class="glossdiv"><h3 class="title">B</h3><dl><dt><a id="blob"/>BLOB</dt><dd><p>Binary Large Object，二进制大对象。</p></dd></dl></div><div class="glossdiv"><h3 class="title">D</h3><dl><dt><a id="dirty-read"/>Dirty Read</dt><dd><p>脏读，线程 1 写入了数据，线程 2 读取了线程 1 所写入的数据。
                线程 1 更改了数据，最后线程 2 读取的是没有更新的旧数据</p></dd></dl></div><div class="glossdiv"><h3 class="title">F</h3><dl><dt><a id="faq"/>FAQ</dt><dd><p>Frequently Asked Questions，常见问题。</p></dd><dt><a id="fqn"/>Fqn</dt><dd><p>Fully Qualified Name，全路径名。</p></dd></dl></div><div class="glossdiv"><h3 class="title">I</h3><dl><dt><a id="ioc"/>IOC</dt><dd><p>Inversion of Control，反转控制。</p></dd></dl></div><div class="glossdiv"><h3 class="title">J</h3><dl><dt><a id="jdbc"/>JDBC</dt><dd><p>Java Data Base Connectivity，Java 数据库连接是一个数据库驱动程序，
                可用来以编程方式连接到数据库。
                这个连接可以用作应用程序与实际的数据库之间的一座桥梁。</p></dd><dt><a id="jmx"/>JMX</dt><dd><p>Java Management Extensions,是一个为应用程序植入管理功能的框架。</p></dd><dt><a id="jndi"/>JNDI</dt><dd><p>Java Naming and Directory Interface，JAVA命名和目录服务。</p></dd><dt><a id="jta"/>JTA</dt><dd><p>Java Transaction API，是一个独立于实现和协议的高级 API，
                   它使应用程序和应用服务器可以访问事务。
                   参见
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/products/jta/">JTA
                    </a>。
                </p></dd><dt><a id="jvm"/>JVM</dt><dd><p>Java Virtual Machines，Java虚拟机。</p></dd></dl></div><div class="glossdiv"><h3 class="title">L</h3><dl><dt><a id="lfu"/>LFU</dt><dd><p>Least Frequently Used，最少使用。</p></dd></dl></div><div class="glossdiv"><h3 class="title">M</h3><dl><dt><a id="map"/>Map</dt><dd><p>java.util.Map，Java 核心库中的一个数据结构，用键/值对的形式存储数据。</p></dd><dt><a id="mbean"/>MBean</dt><dd><p>一个能代表管理资源的Java对象，
                   遵从一定的设计模式，还需实现该规范定义的特定的接口。</p></dd></dl></div><div class="glossdiv"><h3 class="title">N</h3><dl><dt><a id="non-repeatable-read"/>Non-Repeatable Read</dt><dd><p>不可重复读，是指事务 1 读取数据后，事务 2 执行更新操作，使 1 无法再现前一次读取结果。</p></dd></dl></div><div class="glossdiv"><h3 class="title">P</h3><dl><dt><a id="passivation"/>Passivation</dt><dd><p>是指将数据从缓存转移到持久存储区中，腾空内存，它是激活（Activation）的反向操作。</p></dd><dt><a id="phantom-read"/>Phantom Read</dt><dd><p>幻像读，一行数据满足搜索规则，却在开始没有被看到。
                例如：事务1读取了一系列满足搜索规则的行，而事务2插入或删除了一个满足事务1搜索行。</p></dd><dt><a id="pojo"/>POJO</dt><dd><p>Plain Old Java Object,简单Java对象。</p></dd></dl></div><div class="glossdiv"><h3 class="title">R</h3><dl><dt><a id="rpc"/>RPC</dt><dd><p>Remote Procedure Call，远程过程调用。</p></dd></dl></div><div class="glossdiv"><h3 class="title">S</h3><dl><dt><a id="sar"/>SAR</dt><dd><p>Service Archive，服务归档。</p></dd><dt><a id="session_affinity"/>Session Affinity</dt><dd><p>会话亲缘性，也被称作粘性对话（sticky sessions），当一个客户浏览器第一次发送页面请求时，
                负载平衡器将请求转向多个 Web 服务器中的一个，
                当该客户浏览器发送更多请求时，这些请求会自动被转发到同一个 Web 服务器中，
                因此，这个用户的Session是被保留的。</p></dd></dl></div><div class="glossdiv"><h3 class="title">U</h3><dl><dt><a id="utc"/>UTC</dt><dd><p>Universal Time Coordinated，协调世界时。</p></dd></dl></div><div class="glossdiv"><h3 class="title">W</h3><dl><dt><a id="write_through"/>Write-through</dt><dd><p>如果在执行写操作时，数据同时写入缓存和主存称为写通（Write-through），
                该方法操作简单，可随时保持Cache和主存数据的一致性，但可能增加多次不必要的写入。
                </p></dd></dl></div></div></div></body></html>